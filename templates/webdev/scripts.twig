{% extends 'layout' %}
{% block main %}
<main class="bd-masthead" id="content" role="main">
  <div class="container">

    <hr>

    <ul class="list-group">
      <a class="list-group-item list-group-item-action" href="#cake">CAKEPHP3 SCRIPTS</a>
      <a class="list-group-item list-group-item-action" href="#markdown">Documentation MarkDown</a>
      <a class="list-group-item list-group-item-action" href="#lamp18.04">How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 18.04</a>
      <a class="list-group-item list-group-item-action" href="#lamp16.04">How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 16.04</a>
      <a class="list-group-item list-group-item-action" href="#apache">Setup Let’s Encrypt With Apache on Ubuntu 14.04</a>
      <a class="list-group-item list-group-item-action" href="#ssh">How To Confissgure SSH Key-Based Authentication on a Linux Server</a>
      <a class="list-group-item list-group-item-action" href="#ufw">How To Set Up a Firewall with UFW on Ubuntu 16.04</a>
      <a class="list-group-item list-group-item-action" href="#vhostosx">How to set up Virtual Hosts in Apache on macos Sierra and OSX</a>
      <a class="list-group-item list-group-item-action" href="#vhostapache">How To Set Up Apache Virtual Hosts on Ubuntu 14.04 LTS</a>
      <a class="list-group-item list-group-item-action" href="#postfix16.04">How To Install and Configure Postfix on Ubuntu 16.04</a>
      {% set entries = craft.entries().section('secscrpt') %}
      {% for entry in entries %}
      <a class="list-group-item list-group-item-action" href="#{{ block.dlink }}">{{ block.dlink }}</a>
      {% endfor %}
    </ul>

    <!--  -->
    <br>
    <hr>
    <br>
    <h2 id="cake">CAKEPHP Scripts</h2>

    <p class="lead"> php cake.php bake migration AddColumnsToTableName colname:integer </p>

    <!--  -->

    <hr>

    <h2 id="markdown">Documentation Markdown</h2>

    <p class="lead"> You can use the <a href="https://github.com/agencia-drible/drible/edit/master/README.md" target="_blank">editor on GitHub</a> to maintain and preview the content for your website in Markdown files.</p>

    <p class="lead"> Whenever you commit to this repository, GitHub Pages will run <a href="https://jekyllrb.com" target="_blank">Jekyll</a> to rebuild the pages in your site, from the content in your Markdown files.</p>

    <h3>Markdown</h3>

    <p class="lead"> Markdown is a lightweight and easy-to-use syntax for styling your writing. It includes conventions for: </p>

    <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Syntax highlighted code block

      <span class="gh"># Header 1</span>
      <span class="gu">## Header 2</span>
      <span class="gu">### Header 3</span>
      <span class="p">-</span> Bulleted
      <span class="p">-</span> List
      <span class="p">1.</span> Numbered
      <span class="p">2.</span> List
      <span class="gs">**Bold**</span>and _Italic_ and <span class="sb">`Code`</span>text
      <span class="p">[</span><span class="nv">Link</span><span class="p">](</span><span class="sx">url</span><span class="p">)</span>
      and
      !<span class="p">[</span><span class="nv">Image</span><span class="p">](</span><span class="sx">src</span><span class="p">)</span>
    </code>
  </pre>
</div>
</div>


<h3>Jekyll Themes</h3>

<p class="lead">Your Pages site will use the layout and styles from the Jekyll theme you have selected in your <a href="https://github.com/popperz0r/sys-config/settings" target="_blank">repository settings</a>. The name of this theme is saved in the Jekyll <code class="highlighter-rouge">_config.yml</code> configuration file.</p>

<h3>Support or Contact</h3>

<p class="lead">Having trouble with Pages? Check out our <a href="https://help.github.com/categories/github-pages-basics/" target="_blank">documentation</a> or <a href="https://github.com/contact" target="_blank">contact support</a> and we’ll help you sort it out.</p>

<!--  -->

<hr>

<p class="lead"></p>
<div class="text-center">
  <img src="/img/img2.png" class="img-fluid"/>
  <p class="lead"></p>
  <h2 id="lamp18.04">How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 18.04</h2>
</div>
</br>
</br>
<h4> Introduction </h4>
<p class="lead"> A "LAMP" stack is a group of open-source software that is typically installed together to enable a server to host dynamic websites and web apps. This term is actually an acronym which represents the Linux operating system, with the Apache web server. The site data is stored in a MySQL database, and dynamic content is processed by PHP. </p>
</br>
<p class="lead"> In this guide, we will install a LAMP stack on an Ubuntu 18.04 server. </p>
<h4>Prerequisites</h4>
<p class="lead"> In order to complete this tutorial, you will need to have an Ubuntu 18.04 server with a non-root <code>sudo-</code>enabled user account and a basic firewall. This can be configured using our <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-18-04"><u> initial server setup guide for Ubuntu 18.04.</u></a></p>
<p class="lead">The Apache web server is among the most popular web servers in the world. It's well-documented and has been in wide use for much of the history of the web, which makes it a great default choice for hosting a website.</p>
<h3>Step 1 — Installing Apache and Updating the Firewall</h3>
<p class="lead">Install Apache using Ubuntu's package manager,<code>apt</code>:</p>
<code> $ sudo apt update </code>
<code> $ sudo apt install apache2 </code>
<p class="lead">Since this is a <code>sudo</code> command, these operations are executed with root privileges. It will ask you for your regular user's password to verify your intentions. </p>
<h4>Adjust the Firewall to Allow Web Traffic</h4>
<p class="lead">Once you've entered your password, <code>apt</code> will tell you which packages it plans to install and how much extra disk space they'll take up. Press <code>Y</code> and hit <code>ENTER</code> to continue, and the installation will proceed.</p>
<p class="lead">Next, assuming that you have followed the initial server setup instructions and enabled the UFW firewall, make sure that your firewall allows HTTP and HTTPS traffic. You can check that UFW has an application profile for Apache like so:</p>
<code> $ sudo ufw app list</code>
<code>Output</code>
<p class="lead"></p>
<p class="lead">Available applications:</p>
<code>Apache</br></code>
<code>Apache Full</br></code>
<code>Apache Secure</br></code>
<code>OpenSSH</code>
<p class="lead"></p>
<p class="lead">If you look at the <code>Apache Full</code> profile, it should show that it enables traffic to ports <code>80</code> and <code>443</code>:</p>
<code> $ sudo ufw app info "Apache Full"</code>
<code>Output</code>
<p class="lead"></p>
<p class="lead">Profile: Apache Full</p>
<p class="lead">Title: Web Server (HTTP,HTTPS)</p>
<p class="lead">Description: Apache v2 is the next generation of the omnipresent Apache web server. </p>
<p class="lead">Ports:</p>
<p class="lead">80,443/tcp</p>
<p class="lead">Allow incoming HTTP and HTTPS traffic for this profile:</p>
<code> $ sudo ufw allow in "Apache Full" </code>
<p class="lead"></p>
<p class="lead">You can do a spot check right away to verify that everything went as planned by visiting your server's public IP address in your web browser (see the note under the next heading to find out what your public IP address is if you do not have this information already):</p>
<code>http://your_server_ip</code>
<p class="lead"></p>
<p class="lead">You will see the default Ubuntu 18.04 Apache web page, which is there for informational and testing purposes. It should look something like this:</p>
<img src="/img/apache.png" class="img-fluid"/>
<p class="lead"></p>
<p class="lead">If you see this page, then your web server is now correctly installed and accessible through your firewall.</p>
<h4>How To Find your Server's Public IP Address</h4>
<p class="lead">If you do not know what your server's public IP address is, there are a number of ways you can find it. Usually, this is the address you use to connect to your server through SSH.</p>
<p class="lead">There are a few different ways to do this from the command line. First, you could use the <code>iproute2</code> tools to get your IP address by typing this:</p>
<code> $ ip addr show eth0 | grep inet | awk '{ print $2; }' | sed 's/\/.*$//' </code>
<p class="lead"></p>

<p class="lead">This will give you two or three lines back. They are all correct addresses, but your computer may only be able to use one of them, so feel free to try each one.</p>
<p class="lead">An alternative method is to use the <code>curl</code> utility to contact an outside party to tell you how <em>it</em> sees your server. This is done by asking a specific server what your IP address is:</p>
<code>$ sudo apt install curl</code>
<code>$ curl http://icanhazip.com </code>
<p class="lead"></p>
<p class="lead">Regardless of the method you use to get your IP address, type it into your web browser's address bar to view the default Apache page.</p>
<h3>Step 2 — Installing MySQL</h3>
<p class="lead">Now that you have your web server up and running, it is time to install MySQL. MySQL is a database management system. Basically, it will organize and provide access to databases where your site can store information.</p>
<p class="lead">Again, use <code>apt</code> to acquire and install this software:</p>
<p class="lead"></p>
<code> $ sudo apt install mysql-server</code>
<p class="lead"></p>
<p class="lead"><strong>Note</strong>: In this case, you do not have to run <code>sudo apt update</code> prior to the command. This is because you recently ran it in the commands above to install Apache. The package index on your computer should already be up-to-date.</p>
<p class="lead">This command, too, will show you a list of the packages that will be installed, along with the amount of disk space they'll take up. Enter <code>Y</code> to continue.</p>
<p class="lead">When the installation is complete, run a simple security script that comes pre-installed with MySQL which will remove some dangerous defaults and lock down access to your database system. Start the interactive script by running:</p>
<code>$ sudo mysql_ secure_ installation</code>
<p class="lead"></p>
<p class="lead">This will ask if you want to configure the <code>VALIDATE PASSWORD PLUGIN</code>.</p>
<p class="lead"><strong>Note:</strong> Enabling this feature is something of a judgment call. If enabled, passwords which don't match the specified criteria will be rejected by MySQL with an error. This will cause issues if you use a weak password in conjunction with software which automatically configures MySQL user credentials, such as the Ubuntu packages for phpMyAdmin. It is safe to leave validation disabled, but you should always use strong, unique passwords for database credentials.</p>
<p class="lead">Answer <code>Y</code> for yes, or anything else to continue without enabling.</p>
<code>VALIDATE PASSWORD PLUGIN can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD plugin? Press y|Y for Yes, any other key for No:</code>
<p class="lead">If you answer “yes”, you'll be asked to select a level of password validation. Keep in mind that if you enter <code>2</code> for the strongest level, you will receive errors when attempting to set any password which does not contain numbers, upper and lowercase letters, and special characters, or which is based on common dictionary words.</p>
<code>There are three levels of password validation policy:
</br>LOW    Length &gt;= 8
</br> MEDIUM Length &gt;= 8, numeric, mixed case, and special characters
</br>STRONG Length &gt;= 8, numeric, mixed case, special characters and dictionary file
</br>Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 1
</code>
<p class="lead"></p>
<p class="lead">Regardless of whether you chose to set up the <code>VALIDATE PASSWORD PLUGIN</code>, your server will next ask you to select and confirm a password for the MySQL <strong>root</strong> user. This is an administrative account in MySQL that has increased privileges. Think of it as being similar to the <strong>root</strong> account for the server itself (although the one you are configuring now is a MySQL-specific account). Make sure this is a strong, unique password, and do not leave it blank. </p>
<p class="lead">If you enabled password validation, you'll be shown the password strength for the root password you just entered and your server will ask if you want to change that password. If you are happy with your current password, enter <code>N</code> for "no" at the prompt:</p>
<code>Using existing password for root.
</br>Estimated strength of the password: 100
</br>Change the password for root ? ((Press y|Y for Yes, any other key for No) : n
</code>
<p class="lead"></p>
<p class="lead">For the rest of the questions, press <code>Y</code> and hit the <code>ENTER</code> key at each prompt. This will remove some anonymous users and the test database, disable remote root logins, and load these new rules so that MySQL immediately respects the changes you have made.</p>
<p class="lead">Note that in Ubuntu systems running MySQL 5.7 (and later versions), the <strong>root</strong> MySQL user is set to authenticate using the <code>auth_socket</code> plugin by default rather than with a password. This allows for some greater security and usability in many cases, but it can also complicate things when you need to allow an external program (e.g., phpMyAdmin) to access the user.</p>
<p class="lead">If you prefer to use a password when connecting to MySQL as <strong>root</strong>, you will need to switch its authentication method from <code>auth_socket</code> to <code>mysql_native_password</code>. To do this, open up the MySQL prompt from your terminal:</p>
<code>$ sudo mysql</code>
<p class="lead"></p>
<p class="lead">Next, check which authentication method each of your MySQL user accounts use with the following command:</p>
<p class="lead"><code>mysql> SELECT user ,authentication_string , plugin,  host FROM mysql.user;</code></p>
<p class="lead"></p>
<code> Output </code>
<p class="lead"></p>
<table style="width:70%">
  <tr>
    <th> user </th>
    <th> authentication_string </th>
    <th> plugin </th>
    <th> host</th>
  </tr>
  <tr>
    <td> root</td>
    <td></td>
    <td> auth_socket</td>
    <td> localhost</td>
  </tr>
  <tr>
    <td> mysql.session</td>
    <td> *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE</td>
    <td> mysql_native_password</td>
    <td> localhost</td>
  </tr>
  <tr>
    <td> mysql.sys</td>
    <td> *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE</td>
    <td> mysql_native_password</td>
    <td> localhost</td>
  </tr>
  <tr>
    <td> debian-sys-maint</td>
    <td> *CC744277A401A7D25BE1CA89AFF17BF607F876FF</td>
    <td> mysql_native_password</td>
    <td> localhost</td>
  </tr>
</table>
<p class="lead"></p>
<p class="lead">In this example, you can see that the <strong>root</strong> user does in fact authenticate using the <code>auth_socket</code> plugin. To configure the <strong>root</strong> account to authenticate with a password, run the following <code>ALTER USER</code> command. Be sure to change <code>password</code> to a strong password of your choosing:</p>
<code> mysql> ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';</code>
<p class="lead"></p>
<p class="lead">Then, run <code>FLUSH PRIVILEGES</code> which tells the server to reload the grant tables and put your new changes into effect:</p>
<code>mysql> FLUSH PRIVILEGES;</code>
<p class="lead"></p>
<p class="lead">Check the authentication methods employed by each of your users again to confirm that <strong>root</strong> no longer authenticates using the <code>auth_socket</code> plugin:</p>
<code>mysql> SELECT user, authentication_string, plugin, host FROM mysql.user;</code>
<p class="lead"></p>
<code> Output</code>
<p class="lead"></p>
<table style="width:70%">
  <tr>
    <th> user </th>
    <th> authentication_string </th>
    <th> plugin </th>
    <th> host</th>
  </tr>
  <tr>
    <td>root</td>
    <td>*3636DACC8616D997782ADD0839F92C1571D6D78F</td>
    <td>mysql_native_password</td>
    <td>localhost</td>
  </tr>
  <tr>
    <td>mysql.session</td>
    <td>*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE</td>
    <td>mysql_native_password</td>
    <td>localhost</td>
  </tr>
  <tr>
    <td>mysql.sys</td>
    <td>*THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE</td>
    <td>mysql_native_password</td>
    <td>localhost</td>
  </tr>
  <tr>
    <td>debian-sys-maint</td>
    <td>*CC744277A401A7D25BE1CA89AFF17BF607F876FF</td>
    <td>mysql_native_password</td>
    <td>localhost</td>
  </tr>
  <td colspan="4"></td>
</table>
</br>4 rows in set (0.00 sec) </code>
<p class="lead">You can see in this example output that the <strong>root</strong> MySQL user now authenticates using a password. Once you confirm this on your own server, you can exit the MySQL shell:</p>
<code>mysql> exit</code>
<p class="lead"></p>
<p class="lead">At this point, your database system is now set up and you can move on to installing PHP, the final component of the LAMP stack.</p>
<h3>Step 3 — Installing PHP</h3>
<p class="lead">PHP is the component of your setup that will process code to display dynamic content. It can run scripts, connect to your MySQL databases to get information, and hand the processed content over to your web server to display.</p>
<p class="lead">Once again, leverage the <code>apt</code> system to install PHP. In addition, include some helper packages this time so that PHP code can run under the Apache server and talk to your MySQL database:</p>
<code>$ sudo apt install php libapache2-mod-php php-mysql</code>
<p class="lead"></p>
<p class="lead">This should install PHP without any problems. We'll test this in a moment.</p>
<p class="lead">In most cases, you will want to modify the way that Apache serves files when a directory is requested. Currently, if a user requests a directory from the server, Apache will first look for a file called <code>index.html</code>. We want to tell the web server to prefer PHP files over others, so make Apache look for an <code>index.php</code> file first.</p>
<p class="lead">To do this, type this command to open the <code>dir.conf</code> file in a text editor with root privileges:</p>
<code> $ sudo nano /etc/apache2/mods-enabled/dir.conf</code>
<p class="lead"></p>
<p class="lead">It will look like this:</p>
<code>/etc/apache2/mods-enabled/dir.conf
</br>&lt;IfModule mod_dir.c&gt;</br>
DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm</br>
&lt;/IfModule&gt;
</code>
<p class="lead"></p>
<p class="lead">When you are finished, save and close the file by pressing <code>CTRL+X</code>. Confirm the save by typing <code>Y</code> and then hit <code>ENTER</code> to verify the file save location.</p>
<p class="lead">After this, restart the Apache web server in order for your changes to be recognized. Do this by typing this:</p>
<code>$ sudo systemctl restart apache2</code>
<p class="lead"></p>
<p class="lead">You can also check on the status of the <code>apache2</code> service using <code>systemctl</code>:</p>
<code>$ sudo systemctl status apache2</code>
<p class="lead"></p>
<code>Sample Output
</br>  ● apache2.service - LSB: Apache2 web server
</br>Loaded: loaded (/etc/init.d/apache2; bad; vendor preset: enabled)
</br>Drop-In: / lib/ systemd/ system/ apache2.service.d
</br>└─apache2-systemd.conf
</br>Active: active (running) since Tue 2018-04-23 14:28:43 EDT; 45s ago
</br>Docs: man:systemd-sysv-generator(8)
</br>Process: 13581 ExecStop=/ etc/ init.d/ apache2 stop (code=exited, status=0/SUCCESS)
</br>Process: 13605 ExecStart=/ etc /init.d/ apache2 start (code=exited, status=0/SUCCESS)
</br>Tasks: 6 (limit: 512)
</br>CGroup: / system.slice / apache2.service
├─13623 /usr/sbin/apache2 -k start
</br>        ├─13626 /usr/sbin/apache2 -k start
</br>        ├─13627 /usr/sbin/apache2 -k start
</br>        ├─13628 /usr/sbin/apache2 -k start
</br>        ├─13629 /usr/sbin/apache2 -k start
</br>        └─13630 /usr/sbin/apache2 -k start
</code>
<p class="lead">Press <code>Q</code> to exit this status output.</p>
<p class="lead">To enhance the functionality of PHP, you have the option to install some additional modules. To see the available options for PHP modules and libraries, pipe the results of <code>apt search</code> into <code>less</code>, a pager which lets you scroll through the output of other commands:</p>
<code>$ apt search php- | less</code>
<p class="lead"></p>
<p class="lead">Use the arrow keys to scroll up and down, and press <code>Q</code> to quit.</p>
<p class="lead">The results are all optional components that you can install. It will give you a short description for each:</p>
<code>bandwidthd-pgsql/bionic 2.0.1+cvs20090917-10ubuntu1 amd64
  Tracks usage of TCP/IP and builds html files with graphs
</br>
bluefish/bionic 2.2.10-1 amd64
advanced Gtk+ text editor for web and software development
</br>
cacti/bionic 1.1.38+ds1-1 all
web interface for graphing of monitoring systems
</br>
ganglia-webfrontend/bionic 3.6.1-3 all
cluster monitoring toolkit - web front-end
</br>
golang-github-unknwon-cae-dev/bionic 0.0 ~ git20160715.0.c6aac99-4 all
PHP-like Compression and Archive Extensions in Go
</br>
haserl/bionic 0.9.35-2 amd64
CGI scripting program for embedded environments
</br>
kdevelop-php-docs/bionic 5.2.1-1ubuntu2 all
transitional package for kdevelop-php
</br>
kdevelop-php-docs-l10n/bionic 5.2.1-1ubuntu2 all
transitional package for kdevelop-php-l10n
</br>…
</br>:
</code>
<p class="lead"></p>
<p class="lead">To learn more about what each module does, you could search the internet for more information about them. Alternatively, look at the long description of the package by typing:</p>
<code>$ apt show package_name</code>
<p class="lead"></p>
<p class="lead">There will be a lot of output, with one field called <code>Description</code> which will have a longer explanation of the functionality that the module provides.</p>
<p class="lead">For example, to find out what the <code>php-cli</code> module does, you could type this:</p>
<code>$ apt show php-cli</code>
<p class="lead"></p>
<p class="lead">Along with a large amount of other information, you'll find something that looks like this:</p>
<code>Output</br>… </br>
  Description: command-line interpreter for the PHP scripting language (default)
  This package provides the /usr/bin/php command interpreter, useful for
  testing PHP scripts from a shell or performing general shell scripting tasks.
  .
  PHP (recursive acronym for PHP: Hypertext Preprocessor) is a widely-used
  open source general-purpose scripting language that is especially suited
  for web development and can be embedded into HTML.
  .
  This package is a dependency package, which depends on Ubuntu's default
  PHP version (currently 7.2).
  …
</code>
<p class="lead"></p>
<p class="lead">If, after researching, you decide you would like to install a package, you can do so by using the <code>apt install</code> command like you have been doing for the other software.</p>
<p class="lead">If you decided that <code>php-cli</code> is something that you need, you could type:</p>
<p class="lead"></p>
<code>$ sudo apt install php-cli</code>
<p class="lead"></p>
<p class="lead">If you want to install more than one module, you can do that by listing each one, separated by a space, following the <code>apt install</code> command, like this:</p>
<code>$ sudo apt install package1 package2 ...</code>
<p class="lead"></p>
<p class="lead">At this point, your LAMP stack is installed and configured. Before making any more changes or deploying an application, though, it would be helpful to proactively test out your PHP configuration in case there are any issues that should be addressed.</p>
<h3>Step 4 — Testing PHP Processing on your Web Server</h3>
<p class="lead">In order to test that your system is configured properly for PHP, create a very basic PHP script called <code>info.php</code>. In order for Apache to find this file and serve it correctly, it must be saved to a very specific directory, which is called the "web root".</p>
<p class="lead">In Ubuntu 18.04, this directory is located at <code>/var/www/html/</code>. Create the file at that location by running:</p>
<code>$ sudo nano /var/www/html/info.php</code>
<p class="lead"></p>
<p class="lead">This will open a blank file. Add the following text, which is valid PHP code, inside the file:</p>
<code>info.php</code>
<code></br> &lt;?php
</br>  phpinfo();
</br>?&gt;
</code>
<p class="lead"></p>
<p class="lead"></p>
<p class="lead">When you are finished, save and close the file.</p>
<p class="lead">Now you can test whether your web server is able to correctly display content generated by this PHP script. To try this out, visit this page in your web browser. You'll need your server's public IP address again.</p>
<p class="lead">The address you will want to visit is:</p>
<code>http://your_server_ip / info.php
</code>
<p class="lead"></p>
<p class="lead">The page that you come to should look something like this:</p>
<img src="/img/img3" class="img-fluid">
<p class="lead"></p>
<p class="lead">This page provides some basic information about your server from the perspective of PHP. It is useful for debugging and to ensure that your settings are being applied correctly.</p>
<p class="lead">If you can see this page in your browser, then your PHP is working as expected.</p>
<p class="lead">You probably want to remove this file after this test because it could actually give information about your server to unauthorized users. To do this, run the following command:</p>
<code>$ sudo rm /var/www/html/info.php</code>
<p class="lead"></p>
<p class="lead">You can always recreate this page if you need to access the information again later.</p>
<h3>Conclusion</h3>
<p class="lead">Now that you have a LAMP stack installed, you have many choices for what to do next.  Basically, you've installed a platform that will allow you to install most kinds of websites and web software on your server.</p>
<p class="lead">As an immediate next step, you should ensure that connections to your web server are secured, by serving them via HTTPS. The easiest option here is to <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-18-04">use Let's Encrypt</a> to secure your site with a free TLS/SSL certificate.</p>
<p class="lead">Some other popular options are:</p>
<ul>
  <li class="lead"><a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-with-lamp-on-ubuntu-16-04"> Install Wordpress</a> the most popular content management system on the internet.</li>
  <li class="lead"><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-on-ubuntu-18-04"> Set Up PHPMyAdmin</a> to help manage your MySQL databases from web browser.</li>
  <li class="lead"><a href="https://www.digitalocean.com/community/articles/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server"> Learn how to use SFTP</a> to transfer files to and from your server.</li>
</ul>

<!--  -->

<hr>

<h2 id="lamp16.04">How To Install Linux, Apache, MySQL, PHP (LAMP) stack on Ubuntu 16.04</h2>

<h3>Introduction</h3>

<p class="lead"> A <b>“LAMP”</b> stack is a group of open source software that is typically installed together to enable a server to host dynamic websites and web apps. This term is actually an acronym which represents the Linux operating system, with the Apache web server. The site data is stored in a <b>MySQL</b> database, and dynamic content is processed by <b>PHP</b>. </p>

<p class="lead"> In this guide, we’ll get a <b>LAMP</b> stack installed on an Ubuntu 16.04 Droplet. Ubuntu will fulfill our first requirement: a Linux operating system.</p>

<h3>Prerequisities</h3>

<p class="lead">Before you begin with this guide, you should have a separate, non-root user account with ‘sudo’ privileges set up on your server. You can learn how to do this by completing steps 1-4 in the <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-16-04" target="_blank">initial server setup for Ubuntu 16.04</a>.</p>

<h3>Step 1: Install Apache and Allow in Firewall</h3>

<p class="lead">The Apache web server is among the most popular web servers in the world. It’s well-documented, and has been in wide use for much of the history of the web, which makes it a great default choice for hosting a website.</p>

<p class="lead">We can install Apache easily using Ubuntu’s package manager, ‘apt’. A package manager allows us to install most software pain-free from a repository maintained by Ubuntu. You can learn more about <a href="https://www.digitalocean.com/community/tutorials/how-to-manage-packages-in-ubuntu-and-debian-with-apt-get-apt-cache" target="_blank">how to use ‘apt’</a> here.</p>

<p class="lead">For our purposes, we can get started by typing these commands:</a>

  <code>sudo apt-get update
    sudo apt-get install apache2
  </code>

  <p class="lead">Since we are using a ‘sudo’ command, these operations get executed with root privileges. It will ask you for your regular user’s password to verify your intentions. Once you’ve entered your password, ‘apt’ will tell you which packages it plans to install and how much extra disk space they’ll take up. Press <b>Y</b> and hit <b>Enter</b> to continue, and the installation will proceed. </p>

  <h4>Set Global ServerName to Suppress Syntax Warnings</h4>

  <p class="lead">Next, we will add a single line to the <code class="highlighter-rouge">/etc/apache2/apache2.conf</code> file to suppress a warning message. While harmless, if you do not set <code class="highlighter-rouge">ServerName</code> globally, you will receive the following warning when checking your Apache configuration for syntax errors:
    <code class="highlighter-rouge">sudo apache2ctl configtest</code>
    Output
    <code class="highlighter-rouge">AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this message
      Syntax OK
    </code>
  </p>

  <p class="lead"> Open up the main configuration file with your text edit: <code class="highlighter-rouge">sudo nano /etc/apache2/apache2.conf</code> Inside, at the bottom of the file, add a ‘ServerName’ directive, pointing to your primary domain name. If you do not have a domain name associated with your server, you can use your server’s public IP address:</p>

  <p class="lead"><b>Note:</b> If you don’t know your server’s IP address, skip down to the section on <a href="https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-16-04#how-to-find-your-server-39-s-public-ip-address" target="_blank">how to find your server’s public IP address</a> to find it. <strong>/etc/apache2/apache2.conf</strong> . . . ServerName server_domain_or_IP. Save and close the file when you are finished.</p>

  <p class="lead">Next, check for syntax errors by typing:</p>

  <p class="lead"> <code>sudo apache2ctl configtest</code> </p>

  <p class="lead"> Since we added the global ‘ServerName’ directive, all you should see is:</p>

  <p class="lead"> <b>Output</b> Syntax OK </p>

  <p class="lead">Restart Apache to implement your changes:</p>

  <p class="lead"> <code>sudo systemctl restart apache2</code> </p>

  <p class="lead">You can now begin adjusting the firewall.</p>

  <h5>Adjust the Firewall to Allow Web Traffic</h5>

  <p class="lead">Next, assuming that you have followed the initial server setup instructions to enable the UFW firewall, make sure that your firewall allows HTTP and HTTPS traffic. You can make sure that UFW has an application profile for Apache like so:</p>

  <p class="lead"><code>sudo ufw app list</code></p>

  <p class="lead"> <b>Output Available applications:</b> ‘Apache Apache Full Apache Secure OpenSSH’ If you look at the Apache Full profile, it should show that it enables traffic to ports 80 and 443: ‘sudo ufw app info “Apache Full”’ <b>Output</b> Profile: Apache Full Title: Web Server (HTTP,HTTPS) Description: Apache v2 is the next generation of the omnipresent Apache web server.</p>

  <p class="lead">Ports: 80,443/tcp</p>

  <p class="lead">Allow incoming traffic for this profile:</p>

  <p class="lead"><code>sudo ufw allow in "Apache Full"</code></p>

  <p class="lead"> You can do a spot check right away to verify that everything went as planned by visiting your server’s public IP address in your web browser (see the note under the next heading to find out what your public IP address is if you do not have this information already): ‘http://your_server_IP_address’ You will see the default Ubuntu 16.04 Apache web page, which is there for informational and testing purposes. It should look something like this:</p>

  <img src="/img/apache_image1.png" alt="Apache">

  <p class="lead"> If you see this page, then your web server is now correctly installed and accessible through your firewall.</p>

  <h4>How To Find your Server’s Public IP Address</h4>

  <p class="lead">If you do not know what your server’s public IP address is, there are a number of ways you can find it. Usually, this is the address you use to connect to your server through SSH. From the command line, you can find this a few ways. First, you can use the ‘iproute2’ tools to get your address by typing this:<code> ip addr show eth0 ! grep inet | awk '{ print $2; }' | sed 's/\/.*$//' </code>.This will give you two or three lines back. They are all correct addresses, but your computer may only be able to use one of them, so feel free to try each one. An alternative method is to use the curl utility to contact an outside party to tell you how it sees your server. You can do this by asking a specific server what your IP address is:<code> sudo apt-get install curl </code> curl http://icanhazip.com’ Regardless of the method you use to get your IP address, you can type it into your web browser’s address bar to get to your server.</p>

  <h4>Step 2: Install MySQL</h4>

  <p class="lead"> Now that we have our web server up and running, it is time to install MySQL. MySQL is a database management system. Basically, it will organize and provide access to databases where our site can store information.Again, we can use apt to acquire and install our software. This time, we’ll also install some other “helper” packages that will assist us in getting our components to communicate with each other:</p>


  <div class="highlighter-rouge">
    <div class="highlight">
      <pre class="highlight">
        <code>sudo apt-get install software-properties-common
          sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xF1656F24C74CD1D8
          sudo add-apt-repository 'deb [arch=amd64,i386,ppc64el] http://mirrors.up.pt/pub/mariadb/repo/10.2/ubuntu xenial main'
          sudo apt update
          sudo apt install mariadb-server
        </code>
      </pre>
    </div>
  </div>


  <p class="lead"> <strong>Note:</strong> In this case, you do not have to run ‘sudo apt-get update’ prior to the command. This is because we recently ran it in the commands above to install Apache. The package index on our computer should already be up-to-date. Again, you will be shown a list of the packages that will be installed, along with the amount of disk space they’ll take up. Enter <b>Y</b> to continue.

    During the installation, your server will ask you to select and confirm a password for the MySQL “root” user. This is an administrative account in MySQL that has increased privileges. Think of it as being similar to the root account for the server itself (the one you are configuring now is a MySQL-specific account, however). Make sure this is a strong, unique password, and do not leave it blank.

    When the installation is complete, we want to run a simple security script that will remove some dangerous defaults and lock down access to our database system a little bit. Start the interactive script by running:
  </p>

  <p class="lead"> <code> mysql_secure_installation </code></p>

  <p class="lead"> You will be asked to enter the password you set for the MySQL root account. Next, you will be asked if you want to configure the ‘VALIDATE PASSWORD PLUGIN’.

    <strong>Warning:</strong> Enabling this feature is something of a judgment call. If enabled, passwords which don’t match the specified criteria will be rejected by MySQL with an error. This will cause issues if you use a weak password in conjunction with software which automatically configures MySQL user credentials, such as the Ubuntu packages for phpMyAdmin. It is safe to leave validation disabled, but you should always use strong, unique passwords for database credentials.

    Answer y for yes, or anything else to continue without enabling.
  </p>

  <p class="lead">
    <code>
      VALIDATE PASSWORD PLUGIN can be used to test passwords
      and improve security. It checks the strength of password
      and allows the users to set only those passwords which are
      secure enough. Would you like to setup VALIDATE PASSWORD plugin?

      Press y|Y for Yes, any other key for No:
    </code>
  </p>

  <p class="lead"> You’ll be asked to select a level of password validation. Keep in mind that if you enter <b>2</b>, for the strongest level, you will receive errors when attempting to set any password which does not contain numbers, upper and lowercase letters, and special characters, or which is based on common dictionary words.</p>

  <p class="lead">
    <code>
      There are three levels of password validation policy:

      LOW    Length >= 8
      MEDIUM Length >= 8, numeric, mixed case, and special characters
      STRONG Length >= 8, numeric, mixed case, special characters and dictionary file

      Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG: 1
    </code>
  </p>

  <p class="lead">
    If you enabled password validation, you’ll be shown a password strength for the existing root password, and asked you if you want to change that password. If you are happy with your current password, enter n for “no” at the prompt: Using existing password for root.

    Estimated strength of the password: 100 Change the password for root ? ((Press y|Y for Yes, any other key for No) : n’ For the rest of the questions, you should press <b>Y</b> and hit the <b>Enter</b> key at each prompt. This will remove some anonymous users and the test database, disable remote root logins, and load these new rules so that MySQL immediately respects the changes we have made.

    At this point, your database system is now set up and we can move on.
  </p>

  <h4>Step 3: Install PHP</h4>

  <p class="lead">PHP is the component of our setup that will process code to display dynamic content. It can run scripts, connect to our MySQL databases to get information, and hand the processed content over to our web server to display.

    We can once again leverage the ‘apt’ system to install our components. We’re going to include some helper packages as well, so that PHP code can run under the Apache server and talk to our MySQL database:

    <code> sudo apt-get install php libapache2-mod-php php-mcrypt php-mysql </code>
    This should install PHP without any problems. We’ll test this in a moment.

    In most cases, we’ll want to modify the way that Apache serves files when a directory is requested. Currently, if a user requests a directory from the server, Apache will first look for a file called ‘index.html’. We want to tell our web server to prefer PHP files, so we’ll make Apache look for an ‘index.php’ file first.

    To do this, type this command to open the <code>dir.conf</code> file in a text editor with root privileges:

    <code> sudo nano /etc/apache2/mods-enabled/dir.conf </code>
  </p>

  <p class="lead">
    It will look like this:

    <b> /etc/apache2/mods-enabled/dir.conf </b>
  </p>

  <div class="highlighter-rouge">
    <div class="highlight">
      <pre class="highlight">
        <code>&lt;IfModule mod_dir.c&gt;
          DirectoryIndex index.html index.cgi index.pl index.php index.xhtml index.htm
          &lt;/IfModule&gt;
        </code>
      </pre>
    </div>
  </div>


  <p class="lead">We want to move the PHP index file highlighted above to the first position after the ‘DirectoryIndex’ specification, like this:

    <b> /etc/apache2/mods-enabled/dir.conf </b>
  </p>
  <div class="highlighter-rouge">
    <div class="highlight">
      <pre class="highlight">
        <code>&lt;IfModule mod_dir.c&gt;
          DirectoryIndex index.php index.html index.cgi index.pl index.xhtml index.htm
          &lt;/IfModule&gt;
        </code>
      </pre>
    </div>
  </div>

  <p class="lead"> When you are finished, save and close the file by pressing <b>Ctrl-X</b>. You’ll have to confirm the save by typing <b>Y</b> and then hit <b>Enter</b> to confirm the file save location.

    After this, we need to restart the Apache web server in order for our changes to be recognized. You can do this by typing this:
  </p>

  <p class="lead"> <code> sudo systemctl restart apache2 </code> </p>

  <p class="lead"> We can also check on the status of the ‘apache2’ service using ‘systemctl’: </p>

  <div class="highlighter-rouge">
    <div class="highlight">
      <pre class="highlight">
        <code>sudo systemctl status apache2
          **Sample Output**
          'apache2.service - LSB: Apache2 web server
          Loaded: loaded (/etc/init.d/apache2; bad; vendor preset: enabled)
          Drop-In: /lib/systemd/system/apache2.service.d
          +-apache2-systemd.conf
          Active: active (running) since Wed 2016-04-13 14:28:43 EDT; 45s ago
          Docs: man:systemd-sysv-generator(8)
          Process: 13581 ExecStop=/etc/init.d/apache2 stop (code=exited, status=0/SUCCESS)
          Process: 13605 ExecStart=/etc/init.d/apache2 start (code=exited, status=0/SUCCESS)
          Tasks: 6 (limit: 512)
          CGroup: /system.slice/apache2.service
          +-13623 /usr/sbin/apache2 -k start
          +-13626 /usr/sbin/apache2 -k start
          +-13627 /usr/sbin/apache2 -k start
          +-13628 /usr/sbin/apache2 -k start
          +-13629 /usr/sbin/apache2 -k start
          +-13630 /usr/sbin/apache2 -k start

          Apr 13 14:28:42 ubuntu-16-lamp systemd[1]: Stopped LSB: Apache2 web server.
          Apr 13 14:28:42 ubuntu-16-lamp systemd[1]: Starting LSB: Apache2 web server...
          Apr 13 14:28:42 ubuntu-16-lamp apache2[13605]:  * Starting Apache httpd web server apache2
          Apr 13 14:28:42 ubuntu-16-lamp apache2[13605]: AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerNam
          Apr 13 14:28:43 ubuntu-16-lamp apache2[13605]:  *
          Apr 13 14:28:43 ubuntu-16-lamp systemd[1]: Started LSB: Apache2 web server.
        </code>
      </pre>
    </div>
  </div>

  <h4>Install PHP Modules </h4>

  <p class="lead">To enhance the functionality of PHP, we can optionally install some additional modules.

    To see the available options for PHP modules and libraries, you can pipe the results of ‘apt-cache search’ into ‘less’, a pager which lets you scroll through the output of other commands:

    <code> apt-cache search php- | less </code> Use the arrow keys to scroll up and down, and q to quit.

    The results are all optional components that you can install. It will give you a short description for each:<code> libnet-libidn-perl - Perl bindings for GNU Libidn php-all-dev - package depending on all supported PHP development packages php-cgi - server-side, HTML-embedded scripting language (CGI binary) (default) php-cli - command-line interpreter for the PHP scripting language (default) php-common - Common files for PHP packages php-curl - CURL module for PHP [default] php-dev - Files for PHP module development (default) php-gd - GD module for PHP [default] php-gmp - GMP module for PHP [default] :</code> To get more information about what each module does, you can either search the internet, or you can look at the long description of the package by typing:<code> apt-cache show package_name </code>There will be a lot of output, with one field called ‘Description-en’ which will have a longer explanation of the functionality that the module provides.
  </p>

  <p class="lead"> For example, to find out what the ‘php-cli’ module does, we could type this: ‘apt-cache show php-cli’ Along with a large amount of other information, you’ll find something that looks like this: <b>Output</b>  </p>

  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Description-en: command-line interpreter for the PHP scripting language (default)
    This package provides the /usr/bin/php command interpreter, useful for
    testing PHP scripts from a shell or performing general shell scripting tasks.
    .
    PHP (recursive acronym for PHP: Hypertext Preprocessor) is a widely-used
    open source general-purpose scripting language that is especially suited
    for web development and can be embedded into HTML.
    .
    This package is a dependency package, which depends on Debian's default
    PHP version (currently 7.0).
  </code></pre></div></div>

  <p class="lead">If, after researching, you decide you would like to install a package, you can do so by using the ‘apt-get install’ command like we have been doing for our other software.

    If we decided that ‘php-cli’ is something that we need, we could type:<code> sudo apt-get install php-cli </code>If you want to install more than one module, you can do that by listing each one, separated by a space, following the ‘apt-get install’ command, like this:<code> sudo apt-get install package1 package2 ... </code> At this point, your <b>LAMP</b> stack is installed and configured. We should still test out our PHP though.
  </p>

  <h4>Step 4: Test PHP Processing on your Web Server</h4>

  <p class="lead">
    In order to test that our system is configured properly for PHP, we can create a very basic PHP script.

    We will call this script ‘info.php’. In order for Apache to find the file and serve it correctly, it must be saved to a very specific directory, which is called the “web root”.

    In Ubuntu 16.04, this directory is located at ‘/var/www/html/’. We can create the file at that location by typing:<code> sudo nano /var/www/html/info.php </code>. This will open a blank file. We want to put the following text, which is valid PHP code, inside the file: <b>info.php</b> ‘’ When you are finished, save and close the file.

    Now we can test whether our web server can correctly display content generated by a PHP script. To try this out, we just have to visit this page in our web browser. You’ll need your server’s public IP address again.

    The address you want to visit will be: http://your_server_IP_address/info.php The page that you come to should look something like this:
  </p>

  <img src="/img/apache_image2.png" alt="Apache">

  <p class="lead">This page basically gives you information about your server from the perspective of PHP. It is useful for debugging and to ensure that your settings are being applied correctly.

    If this was successful, then your PHP is working as expected.

    You probably want to remove this file after this test because it could actually give information about your server to unauthorized users. To do this, you can type this: ‘sudo rm /var/www/html/info.php’

    You can always recreate this page if you need to access the information again later.
  </p>

  <h3>Conclusion</h3>

  <p class="lead">Now that you have a LAMP stack installed, you have many choices for what to do next. Basically, you’ve installed a platform that will allow you to install most kinds of websites and web software on your server.</p>

  <p class="lead">As an immediate next step, you should ensure that connections to your web server are secured, by serving them via HTTPS. The easiest option here is to <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-16-04">use Let’s Encrypt</a> to secure your site with a free TLS/SSL certificate.</p>

  <p class="lead">Some other popular options are:<a href="https://www.digitalocean.com/community/tutorials/how-to-install-wordpress-on-ubuntu-14-04" target="_blank">-Install Wordpress<a> the most popular content management system on the internet. <a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-on-ubuntu-12-04" target="_blank">-Set Up PHPMyAdmin </a> to help manage your MySQL databases from web browser. <a href="https://www.digitalocean.com/community/tutorials/a-basic-mysql-tutorial" target="_blank">-Learn more about MySQL</a> to manage your databases. <a href="https://www.digitalocean.com/community/tutorials/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server" target="_blank">-Learn how to use SFTP</a> to transfer files to and from your server. <b>Note:</b> We will be updating the links above to our 16.04 documentation as it is written.</p>

  <!--  -->

  <hr>

  <h2 id="apache14.04">Setup Let’s Encrypt With Apache on Ubuntu 14.04</h2>

  <p class="lead"> Let’s Encrypt is a new certificate authority that allows you to issue SSL certificates for free. You can now use SSL without any extra costs. When using an SSL certificate, all traffic between the client and the server is encrypted – which drastically improves your website security. This guide covers the installation of a Let’s Encrypt certificate and automatic renewal on Ubuntu. By the end of this tutorial you will have an Apache server setup on Ubuntu 14.04 with Let’s Encrypt.</p>

  <h3>Step 1: Prerequisites</h3>

  <p class="lead">You will need a Vultr SSD cloud server with Ubuntu 14.04 installed. You will also need a LAMP stack (Apache, PHP, etc.). If you do not yet have a LAMP stack installed on your Vultr server, please refer to the following knowledge base article:<a href="https://www.vultr.com/docs/how-to-install-apache-mysql-and-php-on-ubuntu" target="_blank"> How to Install Apache, MySQL, and PHP on Ubuntu.</a></p>

  Once you have a working LAMP Stack on your Ubuntu Server, you can proceed with with installing Let’s Encrypt.

  In order to generate and install your SSL certificate, you will need Git to clone the Let’s Encrypt repository:</p>

  <p class="lead"> <code> $[ubuntu] apt-get install git $[ubuntu] git clone https://github.com/letsencrypt/letsencrypt </code></p>

  <h3 style="color:#D0AE83;">Step 2: Generating a Let’s Encrypt SSL certificate</h3>

  <p class="lead">Let’s Encrypt verifies your domain by setting up a temporary web server process on your Ubuntu server. This process will run independently of your Apache server. After the SSL certificate has been generated, the temporary web server process will be automatically terminated by the Let’s Encrypt installer. The installer will then install your newly created certificate on the Apache web server.</p>

  <p class="lead"> <code> $[ubuntu] ./letsencrypt-auto --apache -d yourubuntuserver.example </code> </p>

  <p class="lead"> If you want Let’s Encrypt to generate an SSL certificate for even more domains, simply add those domains to the command.</p>

  <p class="lead"> <code> $[ubuntu] ./letsencrypt-auto --apache -d yourubuntuserver.example -d mysslcertificate.example </code> </p>

  <p class="lead"> This feature is very handy for securing your www subdomain. Right now, users who visit your website with the www prefix will get an SSL error. This kind of error will hurt your reputation. In order to resolve it, use a command like this:</p>

  <p class="lead"> <code> $[ubuntu] ./letsencrypt-auto --apache -d yourubuntuserver.example -d www.yourubuntuserver.example </code> </p>

  <p class="lead"> The Let’s Encrypt client will now create a Let’s Encrypt SSL certificate not only for <code>yourubuntuserver.example</code> but also for <code>www.yourubuntuserver.example!</code></p>

  <h3>Step 3: Forcing SSL</h3>

  <p class="lead">You can now force your Apache server to route all HTTP requests to HTTPS. The best way to do this by creating an .htaccess file in your “www root” folder and appending the following rewrite code:</p>

  <div class="highlighter-rouge">
    <div class="highlight">
      <pre class="highlight">
        <code>
          RewriteEngine On
          RewriteCond % 80
          RewriteRule ^(.*)$ https://letsencrypt.example/$1 [R,L]
        </code>
      </pre>
    </div>
  </div>

  <p class="lead">All incoming traffic on the HTTP port 80 will now automatically be redirected to port 443, which utilizes your LE SSL certificate.</p>

  <h3>Step 4: Automatically renewing Let’s Encrypt certificates</h3>

  <p class="lead">As Let’s Encrypt is a free certificate authority, SSL’s can’t be provided for one year or longer. All Let’s Encrypt certificates are valid for 90 days. However, if you want to automatically renew them, this can be automated using a cron job. You can choose to renew certificates when they’re about to expire.</p>

  <p class="lead">Open your crontab:</p>

  <p class="lead"> <code>$[ubuntu] crontab -e</code> </p>

  <p class="lead">Append the following line to the crontab:</p>

  <p class="lead"> <code>15 5 * * 5 /opt/letsencrypt/letsencrypt-auto renew >> /var/log/le-renew.log</code> </p>

  <p class="lead">This cron job runs the <code> /opt/letsencrypt/letsencrypt-auto renew </code> command every Friday at 5:15 A.M. We have chosen to renew the certificates at this time because this is typically a period with little to no traffic on most sites. Therefore, visitors will not notice any delays because the server is under heavy load during the renewal and checking of all Let’s Encrypt certificates.</p>

  <p class="lead">Your Ubuntu Server is now running a fully functional LAMP Stack and your website is using an SSL Certificate form Let’s Encrypt with automatic renewal setup.

    It is possible to use more than one Let’s Encrypt SSL certificate on your server; simply follow step #2 again for each domain.
  </p>

  <p class="lead"> This concludes our tutorial, thank you for reading. </p>

  <!--  -->

  <hr>

  <h2 id="ssh">How To Configure SSH Key-Based Authentication on a Linux Server</h2>

  <h4>Introduction</h4>

  <p class="lead">SSH, or secure shell, is an encrypted protocol used to administer and communicate with servers. When working with a Linux server, chances are, you will spend most of your time in a terminal session connected to your server through SSH.</p>

  <p class="lead">While there are a few different ways of logging into an SSH server, in this guide, we’ll focus on setting up SSH keys. SSH keys provide an easy, yet extremely secure way of logging into your server. For this reason, this is the method we recommend for all users. </p>

  <h3>How Do SSH Keys Work?</h3>

  <p class="lead">An SSH server can authenticate clients using a variety of different methods. The most basic of these is password authentication, which is easy to use, but not the most secure.</p>

  <p class="lead">Although passwords are sent to the server in a secure manner, they are generally not complex or long enough to be resistant to repeated, persistent attackers. Modern processing power combined with automated scripts make brute forcing a password-protected account very possible. Although there are other methods of adding additional security (<code>fail2ban</code>, etc.), SSH keys prove to be a reliable and secure alternative.</p>

  <p class="lead">SSH key pairs are two cryptographically secure keys that can be used to authenticate a client to an SSH server. Each key pair consists of a public key and a private key.</p>

  <p class="lead">The private key is retained by the client and should be kept absolutely secret. Any compromise of the private key will allow the attacker to log into servers that are configured with the associated public key without additional authentication. As an additional precaution, the key can be encrypted on disk with a passphrase.</p>

  <p class="lead">The associated public key can be shared freely without any negative consequences. The public key can be used to encrypt messages that only the private key can decrypt. This property is employed as a way of authenticating using the key pair.</p>

  <p class="lead">The public key is uploaded to a remote server that you want to be able to log into with SSH. The key is added to a special file within the user account you will be logging into called <code>~/.ssh/authorized_keys.</code></p>

  <p class="lead">When a client attempts to authenticate using SSH keys, the server can test the client on whether they are in possession of the private key. If the client can prove that it owns the private key, a shell session is spawned or the requested command is executed.</p>

  <p class="lead">An overview of the flow is shown in this diagram:</p>

  <img src="/img/image_sshkeyauth.png" alt="SSH Key">

  <p class="lead">The diagram shows a laptop connecting to a server, but it could just as easily be one server connecting to another server</p>

  <h>How To Create SSH Keys</h3>

    <p class="lead">The first step to configure SSH key authentication to your server is to generate an SSH key pair on your local computer.</p>

    <p class="lead">To do this, we can use a special utility called ssh-keygen, which is included with the standard OpenSSH suite of tools. By default, this will create a 2048 bit RSA key pair, which is fine for most uses.</p>

    <p class="lead">On your local computer, generate a SSH key pair by typing:</p>

    <p class="lead"><code>ssh-keygen</code></p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Generating public/private rsa key pair.
      Enter file in which to save the key (/home/username/.ssh/id_rsa):
    </code></pre></div></div>

    <p class="lead">The utility will prompt you to select a location for the keys that will be generated. By default, the keys will be stored in the <code>~/.ssh</code> directory within your user’s home directory. The private key will be called <code>id_rsa</code> and the associated public key will be called <code>id_rsa.pub</code>.</p>

    <p class="lead">Usually, it is best to stick with the default location at this stage. Doing so will allow your SSH client to automatically find your SSH keys when attempting to authenticate. If you would like to choose a non-standard path, type that in now, otherwise, press ENTER to accept the default.</p>

    <p class="lead">If you had previously generated an SSH key pair, you may see a prompt that looks like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home/username/.ssh/id_rsa already exists.
      Overwrite (y/n)?
    </code></pre></div></div>

    <p class="lead">If you choose to overwrite the key on disk, you will not be able to authenticate using the previous key anymore. Be very careful when selecting yes, as this is a destructive process that cannot be reversed.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Created directory '/home/username/.ssh'.
      Enter passphrase (empty for no passphrase):
      Enter same passphrase again:
    </code></pre></div></div>

    <p class="lead">Next, you will be prompted to enter a passphrase for the key. This is an optional passphrase that can be used to encrypt the private key file on disk.</p>

    <p class="lead">You may be wondering what advantages an SSH key provides if you still need to enter a passphrase. Some of the advantages are:</p>

    <ul>
      <li class="lead">
        <p class="lead">The private SSH key (the part that can be passphrase protected), is never exposed on the network. The passphrase is only used to decrypt the key on the local machine. This means that network-based brute forcing will not be possible against the passphrase.</p>
      </li>
      <li class="lead">
        <p class="lead">The private key is kept within a restricted directory. The SSH client will not recognize private keys that are not kept in restricted directories. The key itself must also have restricted permissions (read and write only available for the owner). This means that other users on the system cannot snoop.</p>
      </li>
      <li class="lead">
        <p class="lead">Any attacker hoping to crack the private SSH key passphrase must already have access to the system. This means that they will already have access to your user account or the root account. If you are in this position, the passphrase can prevent the attacker from immediately logging into your other servers. This will hopefully give you time to create and implement a new SSH key pair and remove access from the compromised key.</p>
      </li>
    </ul>

    <p class="lead">Since the private key is never exposed to the network and is protected through file permissions, this file should never be accessible to anyone other than you (and the root user). The passphrase serves as an additional layer of protection in case these conditions are compromised.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A passphrase is an optional addition. If you enter one, you will have to provide it every time you use this key (unless you are running SSH agent software that stores the decrypted key). We recommend using a passphrase, but if you do not want to set a passphrase, you can simply press ENTER to bypass this prompt.

      Your identification has been saved in /home/username/.ssh/id_rsa.
      Your public key has been saved in /home/username/.ssh/id_rsa.pub.
      The key fingerprint is:
      a9:49:2e:2a:5e:33:3e:a9:de:4e:77:11:58:b6:90:26 username@remote_host
      The key's randomart image is:
      +--[ RSA 2048]----+
      |     ..o         |
      |   E o= .        |
      |    o. o         |
      |        ..       |
      |      ..S        |
      |     o o.        |
      |   =o.+.         |
      |. =++..          |
      |o=++.            |
      +-----------------+
    </code></pre></div></div>

    <p class="lead">You now have a public and private key that you can use to authenticate. The next step is to place the public key on your server so that you can use SSH key authentication to log in.</p>

    <h3>How to Embed your Public Key when Creating your Server</h3>

    <p class="lead">If you are starting up a new DigitalOcean server, you can automatically embed your SSH public key in your new server’s root account.</p>

    <p class="lead">Towards the bottom of the Droplet creation page, there is an option to add SSH keys to your server:</p>

    <img src="/img/image_addsshkeys1.png" alt="Add SSH Key">

    <p class="lead">If you have already added a public key file to your DigitalOcean account, you will see it here as a selectable option (there are two existing keys in the example above: “Work key” and “Home key”). To embed an existing key, simply click on it and it will highlight. You can embed multiple keys on a single server:</p>

    <img src="/img/image_addsshkeys2.png" alt="SSH Key">

    <p class="lead">If you do not already have a public SSH key uploaded to your account, or if you would like to add a new key to your account, click on the “+ Add SSH Key” button. This will expand to a prompt:</p>

    <img src="/img/image_addsshkeys3.png" alt="SSH Key">

    <p class="lead">In the “SSH Key content” box, paste the content of your SSH public key. Assuming you generated your keys using the method above, you can obtain your public key contents on your local computer by typing:</p>

    <p class="lead"><code> cat ~/.ssh/id_rsa.pub </code></p>

    <p class="lead"><code> ssh-rsa  </code></p>

    <p class="lead"><code> AAAAB3NzaC1yc2EAAAADAQABAAABAQDNqqi1mHLnryb1FdbePrSZQdmXRZxGZbo0gTfglysq6KMNU NY2VhzmYN9JYW39yNtjhVxqfW6ewc+eHiL+IRRM1P5ecDAaL3 V0ou6ecSurU+t9DR4114mzNJ5SqNxMgiJzbXdhR+j55GjfXdk0FyzxM3a5qpVcGZEXiAzGzhHytUV51+YGnuLGaZ37nebh4UlYC+KJe v4MYIVww0tWmY+9GniRSQlgLLUQZ+FcBUjaqhwqVqsHe4F/w oW1IHe7mfm63GXyBavVc+llrEzRbMO111MogZUcoWDI9w7UIm8Z OTnhJsk7jhJzG2GpSXZHmly/a/buFaaFnmfZ4MY PkgJD username@example.com </code></p>

    <p class="lead">Paste this value, in its entirety, into the larger box. In the “Comment (optional)” box, you can choose a label for the key. This will be displayed as the key name in the DigitalOcean interface:</p>

    <img src="/img/image_addsshkeys4.png" alt="SSH Key">

    <p class="lead">When you create your Droplet, the public SSH keys that you selected will be placed in the <code>~/.ssh/authorized_keys</code> file of the root user’s account. This will allow you to log into the server from the computer with your private key.</p>

    <h3>How To Copy a Public Key to your Server</h3>

    <p class="lead">If you already have a server available and did not embed keys upon creation, you can still upload your public key and use it to authenticate to your server.</p>

    <p class="lead">The method you use depends largely on the tools you have available and the details of your current configuration. The following methods all yield the same end result. The easiest, most automated method is first and the ones that follow each require additional manual steps if you are unable to use the preceding methods.</p>

    <h4>Copying your Public Key Using SSH-Copy-ID</h4>

    <p class="lead">The easiest way to copy your public key to an existing server is to use a utility called <code>ssh-copy-id</code>. Because of its simplicity, this method is recommended if available.</p>

    <p class="lead">The <code>ssh-copy-id</code> tool is included in the OpenSSH packages in many distributions, so you may have it available on your local system. For this method to work, you must already have password-based SSH access to your serve</p>

    <p class="lead">To use the utility, you simply need to specify the remote host that you would like to connect to and the user account that you have password SSH access to. This is the account where your public SSH key will be copied.</p>

    <p class="lead">The syntax is:</p>

    <p class="lead"><code>ssh-copy-id username@remote_host</code></p>

    <p class="lead">You may see a message like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The authenticity of host '111.111.11.111 (111.111.11.111)' can't be established.
      ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
      Are you sure you want to continue connecting (yes/no)? yes
    </code></pre></div></div>

    <p class="lead">This just means that your local computer does not recognize the remote host. This will happen the first time you connect to a new host. Type “yes” and press ENTER to continue.</p>

    <p class="lead">Next, the utility will scan your local account for the id_rsa.pub key that we created earlier. When it finds the key, it will prompt you for the password of the remote user’s account:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
      /usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
      username@111.111.11.111's password:
    </code></pre></div></div>

    <p class="lead">Type in the password (your typing will not be displayed for security purposes) and press ENTER. The utility will connect to the account on the remote host using the password you provided. It will then copy the contents of your <code>~/.ssh/id_rsa.pub</code> key into a file in the remote account’s home <code>~/.ssh</code> directory called <code>authorized_keys</code>.</p>

    <p class="lead">You will see output that looks like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Number of key(s) added: 1

      Now try logging into the machine, with:   "ssh 'username@111.111.11.111'"
      and check to make sure that only the key(s) you wanted were added.
    </code></pre></div></div>

    <p class="lead">At this point, your <code>id_rsa.pub</code> key has been uploaded to the remote account. You can continue onto the next section.</p>

    <h4>Copying your Public Key Using SSH</h4>

    <p class="lead">f you do not have <code>ssh-copy-id</code> available, but you have password-based SSH access to an account on your server, you can upload your keys using a conventional SSH method.</p>

    <p class="lead">We can do this by outputting the content of our public SSH key on our local computer and piping it through an SSH connection to the remote server. On the other side, we can make sure that the <code>~/.ssh</code> directory exists under the account we are using and then output the content we piped over into a file called <code>authorized_keys</code> within this directory.</p>

    <p class="lead">We will use the <code> >> </code> redirect symbol to append the content instead of overwriting it. This will let us add keys without destroying previously added keys.</p>

    <p class="lead">The full command will look like this:</p>

    <p class="lead"><code>cat ~/.ssh/id_rsa.pub | ssh username@remote_host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"</code></p>

    <p class="lead">You may see a message like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The authenticity of host '111.111.11.111 (111.111.11.111)' can't be established.
      ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
      Are you sure you want to continue connecting (yes/no)? yes
    </code></pre></div></div>

    <p class="lead">This just means that your local computer does not recognize the remote host. This will happen the first time you connect to a new host. Type “yes” and press ENTER to continue.</p>

    <p class="lead">Afterwards, you will be prompted with the password of the account you are attempting to connect to:</p>

    <p class="lead"><code> username@111.111.11.111's password: </code> </p>

    <p class="lead">After entering your password, the content of your <code>id_rsa.pub</code> key will be copied to the end of the <code>authorized_keys</code> file of the remote user’s account. Continue to the next section if this was successful.</p>

    <h4>Copying your Public Key Manually</h4>

    <p class="lead">If you do not have password-based SSH access to your server available, you will have to do the above process manually.</p>

    <p class="lead">The content of your <code>id_rsa.pub</code> file will have to be added to a file at <code>~/.ssh/authorized_keys</code> on your remote machine somehow.</p>

    <p class="lead">To display the content of your <code>id_rsa.pub</code> key, type this into your local computer:</p>

    <p class="lead"><code> cat ~/.ssh/id_rsa.pub </code></p>

    <p class="lead">You will see the key’s content, which may look something like this:</p>

    <p class="lead"><code>ssh-rsa</code></p>

    <p class="lead"><code>AAAAB3NzaC1yc2EAAAADAQABAAACAQCqql6MzstZYh2TmWWv11q5O3pISj2ZFl9Hgh2JLknLL x44+tXfJ7mIrKNxOOwxIxvcBF8PXSYvobFYEZjGIVCEAjrUzLiIxbyCoxVyle7Q+ bqgZ8SeeM8wzytsY+dVGcBxF6N4JS+zVk5eMcV385gG3Y6ON3EG112n6d+SMXY0OEBIcO6x+PnUSGHrSgpBgX7Ks1r 7xqFa7heJLLt2wWwkARptX7udSq05paBhcpB0pHtA1Rfz3K2B+ZVIpSDfki9UVKzT8JUmwW6NNzSgxU fQHGwnW7kj4jp4AT0VZk3ADw497M2G/12N0PPB5CnhHf7ovgy6nL1ikrygTK RFmNZISvAcywB9GVqNAVE+ZHDSCu URNsAInVzgYo9xgJDW8wUw2o8U77+xiFxgI5QSZX3Iq7YLMgeksa O4rBJEa54k8m5wEiEE1nUhLuJ0X/ vh3xPff6SQ1BL/zkOhvJCACK6Vb15mDOe CSq54Cr7kvS46itMosi/uS66+PujOO+xt/2FWYepz6ZlN70bR ly57Q06J+ZJoc9FfBCbCyYH7U/ASsmY09 5ywPsBo1XQ9PqhnN 1/YOorJ068foQDNVpm146mUpILVxmq41Cj55YKHEazXGsdBIbXWhcrRf4G2fJLRcGUr9q8/lER o9 oxRm5JFX6TCmj6kmiFqv+Ow9gI0x8GvaQ== demo@test</code></p>

    <p class="lead">Access your remote host using whatever method you have available. For instance, if your server is a DigitalOcean Droplet, you can log in using the web console in the control panel:</p>

    <img src="/img/image_addsshkeys5.png" alt="SSH Key Manually">

    <p class="lead">Once you have access to your account on the remote server, you should make sure the <code>~/.ssh</code> directory is created. This command will create the directory if necessary, or do nothing if it already exists:</p>

    <p class="lead"><code> mkdir -p ~/.ssh </code></p>

    <p class="lead">Now, you can create or modify the <code>authorized_keys</code> file within this directory. You can add the contents of your <code>id_rsa.pub</code> file to the end of the <code>authorized_keys</code> file, creating it if necessary, using this:</p>

    <p class="lead"><code>echo public_key_string >> ~/.ssh/authorized_keys</code></p>

    <p class="lead">In the above command, substitute the public_key_string with the output from the <code>cat ~/.ssh/id_rsa.pub</code> command that you executed on your local system. It should start with <code>ssh-rsa AAAA...</code>.</p>

    <p class="lead">If this works, you can move on to try to authenticate without a password.</p>

    <h3>Authenticate to your Server Using SSH Keys</h3>

    <p class="lead">If you have successfully completed one of the procedures above, you should be able to log into the remote host without the remote account’s password.</p>

    <p class="lead">The basic process is the same:</p>

    <p class="lead"><code>ssh username@remote_host</code></p>

    <p class="lead">If this is your first time connecting to this host (if you used the last method above), you may see something like this:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The authenticity of host '111.111.11.111 (111.111.11.111)' can't be established.
      ECDSA key fingerprint is fd:fd:d4:f9:77:fe:73:84:e1:55:00:ad:d6:6d:22:fe.
      Are you sure you want to continue connecting (yes/no)? yes
    </code></pre></div></div>

    <p class="lead">This just means that your local computer does not recognize the remote host. Type “yes” and then press ENTER to continue.</p>

    <p class="lead">If you did not supply a passphrase for your private key, you will be logged in immediately. If you supplied a passphrase for the private key when you created the key, you will be required to enter it now. Afterwards, a new shell session should be spawned for you with the account on the remote system.</p>

    <p class="lead">If successful, continue on to find out how to lock down the server.</p>

    <h4>Disabling Password Authentication on your Server</h4>

    <p class="lead">If you were able to login to your account using SSH without a password, you have successfully configured SSH key-based authentication to your account. However, your password-based authentication mechanism is still active, meaning that your server is still exposed to brute-force attacks.</p>

    <p class="lead">Before completing the steps in this section, make sure that you either have SSH key-based authentication configured for the root account on this server, or preferably, that you have SSH key-based authentication configured for an account on this server with <code>sudo</code> access. This step will lock down password-based logins, so ensuring that you have will still be able to get administrative access is essential.</p>

    <p class="lead">Once the above conditions are true, log into your remote server with SSH keys, either as root or with an account with <code>sudo</code> privileges. Open the SSH daemon’s configuration file:</p>

    <p class="lead"><code> sudo nano /etc/ssh/sshd_config </code></p>

    <p class="lead">Inside the file, search for a directive called <code>PasswordAuthentication</code>. This may be commented out. Uncomment the line and set the value to “no”. This will disable your ability to log in through SSH using account passwords:</p>

    <p class="lead"><code>PasswordAuthentication no</code></p>

    <p class="lead">Save and close the file when you are finished. To actually implement the changes we just made, you must restart the service.</p>

    <p class="lead">On Ubuntu or Debian machines, you can issue this command:</p>

    <p class="lead"><code>sudo service ssh restart</code></p>

    <p class="lead">On CentOS/Fedora machines, the daemon is called <code>sshd</code>:</p>

    <p class="lead"><code> sudo service sshd restart </code></p>

    <p class="lead">After completing this step, you’ve successfully transitioned your SSH daemon to only respond to SSH keys.</p>

    <h4>Conclusion</h4>

    <p class="lead">You should now have SSH key-based authentication configured and running on your server, allowing you to sign in without providing an account password. From here, there are many directions you can head. If you’d like to learn more about working with SSH, take a look at our <a href="https://www.digitalocean.com/community/tutorials/ssh-essentials-working-with-ssh-servers-clients-and-keys" target="_blank">SSH essentials guide</a>.</p>

    <!--  -->

    <hr>

    <h2 id="ufw">How To Set Up a Firewall with UFW on Ubuntu 16.04</h2>

    <h3>Introduction</h3>

    <p class="lead"> UFW, or Uncomplicated Firewall, is an interface to iptables that is geared towards simplifying the process of configuring a firewall. While iptables is a solid and flexible tool, it can be difficult for beginners to learn how to use it to properly configure a firewall. If you’re looking to get started securing your network, and you’re not sure which tool to use, UFW may be the right choice for you.</p>

    <p class="lead">This tutorial will show you how to set up a firewall with UFW on Ubuntu 16.04.</p>

    <h3>Prerequesities</h3>

    <p class="lead">To follow this tutorial, you will need:</p>

    <ul>
      <li class="lead">One Ubuntu 16.04 server with a sudo non-root user, which you can set up by following Steps 1-3 in the <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-16-04" target="_blank">Initial Server Setup with Ubuntu 16.04 tutorial</a>.</li>
    </ul>

    <p class="lead">UFW is installed by default on Ubuntu. If it has been uninstalled for some reason, you can install it with <code>sudo apt-get install ufw</code>.</p>

    <h3>Step 1 — Using IPv6 with UFW (Optional)</h3>

    <p class="lead">This tutorial is written with IPv4 in mind, but will work for IPv6 as well as long as you enable it. If your Ubuntu server has IPv6 enabled, ensure that UFW is configured to support IPv6 so that it will manage firewall rules for IPv6 in addition to IPv4. To do this, open the UFW configuration with nano or your favorite editor.</p>

    <p class="lead"><code>sudo nano /etc/default/ufw</code>

      <p class="lead">Then make sure the value of IPV6 is yes. It should look like this:</p>

      <p class="lead"><b>/etc/default/ufw excerpt</b></p>

      <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
        IPV6=yes
        ...
      </code></pre></div></div>

      <p class="lead">Save and close the file. Now, when UFW is enabled, it will be configured to write both IPv4 and IPv6 firewall rules. However, before enabling UFW, we will want to ensure that your firewall is configured to allow you to connect via SSH. Let’s start with setting the default policies.</p>

      <h3>Step 2 — Allowing SSH Connections</h3>

      <p class="lead">If we enabled our UFW firewall now, it would deny all incoming connections. This means that we will need to create rules that explicitly allow legitimate incoming connections — SSH or HTTP connections, for example — if we want our server to respond to those types of requests. If you’re using a cloud server, you will probably want to allow incoming SSH connections so you can connect to and manage your server. </p>

      <p class="lead">To configure your server to allow incoming SSH connections, you can use this command:</p>

      <p class="lead"><code> sudo ufw allow ssh </code></p>

      <p class="lead">This will create firewall rules that will allow all connections on port <code>22</code>, which is the port that the SSH daemon listens on by default. UFW knows what SSH and a number of other service names mean because they’re listed as services in the <code>/etc/services</code> file.</p>

      <p class="lead">However, we can actually write the equivalent rule by specifying the port instead of the service name. For example, this command works the same as the one above:</p>

      <p class="lead"><code>sudo ufw allow 22</code></p>

      <p class="lead">If you configured your SSH daemon to use a different port, you will have to specify the appropriate port. For example, if your SSH server is listening on port 2222, you can use this command to allow connections on that port:</p>

      <p class="lead"><code>sudo ufw allow 2222</code></p>

      <p class="lead">Now that your firewall is configured to allow incoming SSH connections, we can enable it.</p>

      <h3>Step 3 — Enabling UFW</h3>

      <p class="lead">To enable UFW, use this command:</p>

      <p class="lead"><code> sudo ufw enable </code>

        <p class="lead">You will receive a warning that says the command may disrupt existing SSH connections. We already set up a firewall rule that allows SSH connections, so it should be fine to continue. Respond to the prompt with <code>y</code>.</p>

        <p class="lead">The firewall is now active. Feel free to run the <code>sudo ufw status verbose </code>command to see the rules that are set. The rest of this tutorial covers how to use UFW in more detail, like allowing or denying different kinds of connections.</p>

        <h3>Step 4 — Allowing Other Connections</h3>

        <p class="lead">At this point, you should allow all of the other connections that your server needs to respond to. The connections that you should allow depends your specific needs. Luckily, you already know how to write rules that allow connections based on a service name or port; we already did this for SSH on port <code>22</code>. You can also do this for:</p>

        <ul>
          <li class="lead">
            <p class="lead">HTTP on port 80, which is what unencrypted web servers use, using <code>sudo ufw allow http</code> or <code>sudo ufw allow 80</code></p>
          </li>
          <li class="lead">
            <p class="lead">HTTPS on port 443, which is what encrypted web servers use, using <code>sudo ufw allow https</code> or <code>sudo ufw allow 443</code></p>
          </li>
          <li class="lead">
            <p class="lead">FTP on port 21, which is used for unencrypted file transfers (which you probably shouldn’t use anyway), using <code>sudo ufw allow ftp</code> or <code>sudo ufw allow 21/tcp</code></p>
          </li>
        </ul>

        <p class="lead">There are several others ways to allow other connections, aside from specifying a port or known service.</p>

        <h4>Specific Port Ranges </h4>

        <p class="lead">You can specify port ranges with UFW. Some applications use multiple ports, instead of a single port.

          For example, to allow X11 connections, which use ports <code>6000-6007</code>, use these commands:</p>

          <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo ufw allow 6000:6007/tcp
            sudo ufw allow 6000:6007/udp
          </code></pre></div></div>

          <p class="lead">When specifying port ranges with UFW, you must specify the protocol (tcp or udp) that the rules should apply to. We haven’t mentioned this before because not specifying the protocol simply allows both protocols, which is OK in most cases.</p>

          <h4>Specific IP Addresses</h4>

          <p class="lead">When working with UFW, you can also specify IP addresses. For example, if you want to allow connections from a specific IP address, such as a work or home IP address of <code>15.15.15.51</code>, you need to specify <code>from</code>, then the IP address:</p>

          <p class="lead"> <code>sudo ufw allow from 15.15.15.51</code> </p>

          <p class="lead">You can also specify a specific port that the IP address is allowed to connect to by adding <code>to any port</code> followed by the port number. For example, If you want to allow <code>15.15.15.51</code> to connect to port <code>22</code> (SSH), use this command:</p>

          <p class="lead"><code>sudo ufw allow from 15.15.15.51 to any port 22</code></p>

          <h4>Subnets</h4>

          <p class="lead">If you want to allow a subnet of IP addresses, you can do so using CIDR notation to specify a netmask. For example, if you want to allow all of the IP addresses ranging from <code>15.15.15.1</code> to <code>15.15.15.254</code> you could use this command:</p>

          <p class="lead"><code>sudo ufw allow from 15.15.15.0/24</code></p>

          <p class="lead">Likewise, you may also specify the destination port that the subnet <code>15.15.15.0/24</code> is allowed to connect to. Again, we’ll use port <code>22</code> (SSH) as an example:</p>

          <p class="lead"><code>sudo ufw allow from 15.15.15.0/24 to any port 22</code></p>

          <h4>Connections to a Specific Network Interface</h4>

          <p class="lead">If you want to create a firewall rule that only applies to a specific network interface, you can do so by specifying “allow in on” followed by the name of the network interface.</p>

          <p class="lead">You may want to look up your network interfaces before continuing. To do so, use this command:</p>

          <p class="lead"><code>ip addr</code></p>

          <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
            2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state
            ...
            3: eth2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default
            ...
          </code></pre></div></div>

          <p class="lead">The highlighted output indicates the network interface names. They are typically named something like <code>eth0</code> or <code>eth2</code>.</p>

          <p class="lead">So, if your server has a public network interface called <code>eth0</code>, you could allow HTTP traffic (port <code>80</code>) to it with this command:</p>

          <p class="lead"><code>sudo ufw allow in on eth0 to any port 80</code></p>

          <p class="lead">Doing so would allow your server to receive HTTP requests from the public Internet.</p>

          <p class="lead">Or, if you want your MySQL database server (port <code>3306</code>) to listen for connections on the private network interface <code>eth2</code>, for example, you could use this command:</p>

          <p class="lead"><code>sudo ufw allow in on eth2 to any port 3306</code></p>

          <p class="lead">This would allow other servers on your private network to connect to your MySQL database.</p>

          <h3>Step 5 — Denying Connections</h3>

          <p class="lead">If you haven’t changed the default policy for incoming connections, UFW is configured to deny all incoming connections. Generally, this simplifies the process of creating a secure firewall policy by requiring you to create rules that explicitly allow specific ports and IP addresses through.</p>

          <p class="lead">However, sometimes you will want to deny specific connections based on the source IP address or subnet, perhaps because you know that your server is being attacked from there. Also, if you want change your default incoming policy to <b>allow</b> (which isn’t recommended in the interest of security), you would need to create <b>deny</b> rules for any services or IP addresses that you don’t want to allow connections for.</p>

          <p class="lead">To write <b>deny</b> rules, you can use the commands described above, replacing <b>allow</b> with <b>deny</b></p>

          <p class="lead">For example, to deny HTTP connections, you could use this command:</p>

          <p class="lead"><code>sudo ufw deny http</code></p>

          <p class="lead">Or if you want to deny all connections from <code>15.15.15.51</code> you could use this command:</p>

          <p class="lead"><code>sudo ufw deny from 15.15.15.51</code></p>

          <p class="lead">Now let’s take a look at how to delete rules.</p>

          <h3>Step 6 — Deleting Rules</h3>

          <p class="lead">Knowing how to delete firewall rules is just as important as knowing how to create them. There are two different ways specify which rules to delete: by rule number or by the actual rule (similar to how the rules were specified when they were created). We’ll start with the <b>delete by rule number</b> method because it is easier, compared to writing the actual rules to delete, if you’re new to UFW.</p>

          <h4>By Rule Number</h4>

          <p class="lead">If you’re using the rule number to delete firewall rules, the first thing you’ll want to do is get a list of your firewall rules. The UFW status command has an option to display numbers next to each rule, as demonstrated here:</p>

          <p class="lead"><code>sudo ufw status numbered</code></p>

          <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Status: active

            To                         Action      From
            --                         ------      ----
            [ 1] 22                         ALLOW IN    15.15.15.0/24
            [ 2] 80                         ALLOW IN    Anywhere
          </code></pre></div></div>

          <p class="lead">If we decide that we want to delete rule 2, the one that allows port 80 (HTTP) connections, we can specify it in a UFW delete command like this:</p>

          <p class="lead"><code>sudo ufw delete 2</code></p>

          <p class="lead">This would show a confirmation prompt then delete rule 2, which allows HTTP connections. Note that if you have IPv6 enabled, you would want to delete the corresponding IPv6 rule as well.</p>

          <h4>By Actual Rule</h4>

          <p class="lead">The alternative to rule numbers is to specify the actual rule to delete. For example, if you want to remove the  <code>allow http</code> rule<, you could write it like this:

            <p class="lead"><code>sudo ufw delete allow http</code></p>

            <p class="lead">You could also specify the rule by <code>allow 80</code>, instead of by service name:</p>

            <p class="lead"><code>sudo ufw delete allow 80</code></p>

            <p class="lead">This method will delete both IPv4 and IPv6 rules, if they exist.</p>

            <h3>Step 7 — Checking UFW Status and Rules</h3>

            <p class="lead">At any time, you can check the status of UFW with this command:</p>

            <p class="lead"><code>sudo ufw status verbose</code></p>

            <p class="lead">If UFW is disabled, which it is by default, you’ll see something like this:</p>

            <p class="lead"><code>Status: inactive</code></p>

            <p class="lead">If UFW is active, which it should be if you followed Step 3, the output will say that it’s active and it will list any rules that are set. For example, if the firewall is set to allow SSH (port <code>22</code>) connections from anywhere, the output might look something like this:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Status: active
              Logging: on (low)
              Default: deny (incoming), allow (outgoing), disabled (routed)
              New profiles: skip

              To                         Action      From
              --                         ------      ----
              22/tcp                     ALLOW IN    Anywhere
            </code></pre></div></div>

            <p class="lead">Use the <code>status</code> command if you want to check how UFW has configured the firewall.</p>

            <h3>Step 8 — Disabling or Resetting UFW (optional)</h3>

            <p class="lead">If you decide you don’t want to use UFW, you can disable it with this command:</p>

            <p class="lead"><code>sudo ufw disable</code></p>

            <p class="lead">Any rules that you created with UFW will no longer be active. You can always run <code>sudo ufw enable</code> if you need to activate it later.</p>

            <p class="lead">If you already have UFW rules configured but you decide that you want to start over, you can use the reset command:</p>

            <p class="lead"><code>sudo ufw reset</code></p>

            <p class="lead">This will disable UFW and delete any rules that were previously defined. Keep in mind that the default policies won’t change to their original settings, if you modified them at any point. This should give you a fresh start with UFW.</p>

            <h3>Conclusion</h3>

            <p class="lead">Your firewall should now be configured to allow (at least) SSH connections. Be sure to allow any other incoming connections that your server, while limiting any unnecessary connections, so your server will be functional and secure.</p>

            <p class="lead">To learn about more common UFW configurations, check out the <a href="https://www.digitalocean.com/community/tutorials/ufw-essentials-common-firewall-rules-and-commands" target="_blank">UFW Essentials: Common Firewall Rules and Commands</a> tutorial.</p>

            <!--  -->

            <hr>

            <h2 id="vshostosx">Edit the vhosts.conf file</h2>

            <p class="lead">Open this file to add in the virtual host.</p>

            <p class="lead"> <code> sudo nano /etc/apache2/extra/httpd-vhosts.conf </code> </p>

            <p class="lead"> An example domain in the file is given of the format required to add in additional domains, just follow this to create your new virtual host: </p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
              ServerAdmin webmaster@dummy-host2.example.com
              DocumentRoot "/usr/docs/dummy-host2.example.com"
              ServerName dummy-host2.example.com
              ErrorLog "/private/var/log/apache2/dummy-host2.example.com-error_log"
              CustomLog "/private/var/log/apache2/dummy-host2.example.com-access_log" common
              &lt;/VirtualHost&gt;
            </code></pre></div></div>

            <p class="lead">We can take this example and extend on it, if you wanted a domain named <b>apple.com</b> for example, you can copy the existing text block and edit to suit:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;VirtualHost *:80&gt;
              ServerName apple.com
              ServerAlias www.apple.com
              DocumentRoot "/Users/USERNAME/Sites/apple"
              ErrorLog "/private/var/log/apache2/apple.com-error_log"
              CustomLog "/private/var/log/apache2/apple.com-access_log" common
              ServerAdmin web@coolestguidesontheplanet.com
              &lt;/VirtualHost&gt;
            </code></pre></div></div>

            <p class="lead">So in the example above a vhost for apple.com is created and the document root is in the Sites folder, in the text block above I have also added in some log files, what you need to change is the document root location username and domain name to suit your needs. Finish and save the file.</p>

            <p class="lead">Now also you need to map the IP address to be the localhost.</p>

            <h3>Map Your IP address to localhost</h3>

            <p class="lead"> <code> sudo nano /etc/hosts </code> </p>

            <p class="lead"> Add the Domain and <b>‘www‘</b> alias to resolve to the localhost address </p>

            <p class="lead"> <code> 127.0.0.1 apple.com www.apple.com </code> </p>

            <h3>Restart Apache</h3>

            <p class="lead"> <code> sudo apachectl restart </code> </p>

            <p class="lead"> Check out your local vhost domain in the browser.</p>

            <!--  -->

            <hr>

            <h2 id="vhostapache">Step One — Create the Directory Structure</h2>

            <p class="lead">The first step that we are going to take is to make a directory structure that will hold the site data that we will be serving to visitors.</p>

            <p class="lead">Our <code>document root</code> (the top-level directory that Apache looks at to find content to serve) will be set to individual directories under the <code>/var/www directory</code>. We will create a directory here for both of the virtual hosts we plan on making.</p>

            <p class="lead">Within each of these directories, we will create a <code>public_html</code> folder that will hold our actual files. This gives us some flexibility in our hosting.</p>

            <p class="lead">For instance, for our sites, we’re going to make our directories like this:</p>

            <p class="lead"><code>sudo mkdir -p /var/www/example.com/public_html sudo mkdir -p /var/www/test.com/public_html</code></p>

            <p class="lead">The portions in red represent the domain names that we are wanting to serve from our VPS.</p>

            <h3>Step Two — Grant Permissions</h3>

            <p class="lead">Now we have the directory structure for our files, but they are owned by our root user. If we want our regular user to be able to modify files in our web directories, we can change the ownership by doing this:</p>

            <p class="lead"><code>sudo chown -R $USER:$USER /var/www/example.com/public_html sudo chown -R $USER:$USER </code></p>

            <p class="lead"><code>/var/www/test.com/public_html</code></p>

            <p class="lead">The <code>$USER</code> variable will take the value of the user you are currently logged in as when you press “ENTER”. By doing this, our regular user now owns the <code>public_html</code> subdirectories where we will be storing our content.</p>

            <p class="lead">We should also modify our permissions a little bit to ensure that read access is permitted to the general web directory and all of the files and folders it contains so that pages can be served correctly:</p>

            <p class="lead"><code>sudo chmod -R 755 /var/www</code></p>

            <p class="lead">Your web server should now have the permissions it needs to serve content, and your user should be able to create content within the necessary folders.</p>

            <h3>Step Three — Create Demo Pages for Each Virtual Host</h3>

            <p class="lead">We have our directory structure in place. Let’s create some content to serve.</p>

            <p class="lead">We’re just going for a demonstration, so our pages will be very simple. We’re just going to make an <code>index.html</code> page for each site.</p>

            <p class="lead">Let’s start with <code>example.com</code>. We can open up an <code>index.html</code> file in our editor by typing:</p>

            <p class="lead"><code>nano /var/www/example.com/public_html/index.html</code></p>

            <p class="lead">In this file, create a simple HTML document that indicates the site it is connected to. My file looks like this:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
              <span class="nt">&lt;head&gt;</span>
              <span class="nt">&lt;title&gt;</span>Welcome to Example.com!<span class="nt">&lt;/title&gt;</span>
              <span class="nt">&lt;/head&gt;</span>
              <span class="nt">&lt;body&gt;</span>
              <span class="nt">&lt;h2&gt;</span>Success!  The example.com virtual host is working!<span class="nt">&lt;/h2&gt;</span>
              <span class="nt">&lt;/body&gt;</span>
              <span class="nt">&lt;/html&gt;</span>
            </code></pre></div></div>

            <p class="lead">Save and close the file when you are finished.</p>

            <p class="lead">We can copy this file to use as the basis for our second site by typing:</p>

            <p class="lead"><code>cp /var/www/example.com/public_html/index.html /var/www/test.com/public_html/index.html</code></p>

            <p class="lead">We can then open the file and modify the relevant pieces of information:</p>

            <p class="lead"><code>nano /var/www/test.com/public_html/index.html</code></p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
              <span class="nt">&lt;head&gt;</span>
              <span class="nt">&lt;title&gt;</span>Welcome to Test.com!<span class="nt">&lt;/title&gt;</span>
              <span class="nt">&lt;/head&gt;</span>
              <span class="nt">&lt;body&gt;</span>
              <span class="nt">&lt;h2&gt;</span>Success!  The test.com virtual host is working!<span class="nt">&lt;/h2&gt;</span>
              <span class="nt">&lt;/body&gt;</span>
              <span class="nt">&lt;/html&gt;</span>
            </code></pre></div></div>

            <p class="lead">Save and close this file as well. You now have the pages necessary to test the virtual host configuration.</p>

            <h3>Step Four — Create New Virtual Host Files</h3>

            <p class="lead">Virtual host files are the files that specify the actual configuration of our virtual hosts and dictate how the Apache web server will respond to various domain requests.</p>

            <p class="lead">Apache comes with a default virtual host file called <code>000-default.conf</code> that we can use as a jumping off point. We are going to copy it over to create a virtual host file for each of our domains.</p>

            <p class="lead">We will start with one domain, configure it, copy it for our second domain, and then make the few further adjustments needed. The default Ubuntu configuration requires that each virtual host file end in <code>.conf</code>.</p>

            <h4>Create the First Virtual Host File</h4>

            <p class="lead">Start by copying the file for the first domain:</p>

            <p class="lead"><code> sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/example.com.conf</code></p>

            <p class="lead">Open the new file in your editor with root privileges:</p>

            <p class="lead"><code>sudo nano /etc/apache2/sites-available/example.com.conf</code></p>

            <p class="lead">The file will look something like this (I’ve removed the comments here to make the file more approachable):</p>

            <p class="lead"><code> < VirtualHost *:80> ServerAdmin webmaster@localhost DocumentRoot /var/www/html ErrorLog </code></p>

            <p class="lead"><code> ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </ VirtualHost></code></p>

            <p class="lead">As you can see, there’s not much here. We will customize the items here for our first domain and add some additional directives. This virtual host section matches any requests that are made on port 80, the default HTTP port.</p>

            <p class="lead">First, we need to change the <code>ServerAdmin</code> directive to an email that the site administrator can receive emails through.</p>

            <p class="lead"><code>ServerAdmin admin@example.com</code></p>

            <p class="lead">After this, we need to add two directives. The first, called <code>ServerName</code>, establishes the base domain that should match for this virtual host definition. This will most likely be your domain. The second, called <code>ServerAlias</code>, defines further names that should match as if they were the base name. This is useful for matching hosts you defined, like <code>www:</code></p>

            <p class="lead"><code>ServerName example.com ServerAlias www.example.com</code></p>

            <p class="lead">The only other thing we need to change for a basic virtual host file is the location of the document root for this domain. We already created the directory we need, so we just need to alter the <code>DocumentRoot</code> directive to reflect the directory we created:</p>

            <p class="lead"><code>DocumentRoot /var/www/example.com/public_html</code></p>

            <p class="lead">In total, our virtualhost file should look like this:</p>

            <p class="lead"><code>< VirtualHost *:80> ServerAdmin admin@example.com ServerName example.com ServerAlias www.example.com DocumentRoot /var/www/example.com/public_html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </ VirtualHost></code></p>

            <p class="lead">Save and close the file.</p>

            <h4>Copy First Virtual Host and Customize for Second Domain</h4>

            <p class="lead">Now that we have our first virtual host file established, we can create our second one by copying that file and adjusting it as needed.</p>

            <p class="lead">Start by copying it:</p>

            <p class="lead"><code>sudo cp /etc/apache2/sites-available/example.com.conf /etc/apache2/sites-available/test.com.conf</code></p>

            <p class="lead">Open the new file with root privileges in your editor:</p>

            <p class="lead"><code>sudo nano /etc/apache2/sites-available/test.com.conf</code></p>

            <p class="lead">You now need to modify all of the pieces of information to reference your second domain. When you are finished, it may look something like this:</p>

            <p class="lead"><code> < VirtualHost *:80> ServerAdmin admin@test.com ServerName test.com ServerAlias www.test.com DocumentRoot /var/www/test.com/public_html ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined </ VirtualHost> </code></p>

            <p class="lead">Save and close the file when you are finished.</p>

            <h3>Step Five — Enable the New Virtual Host Files</h3>

            <p class="lead">Now that we have created our virtual host files, we must enable them. Apache includes some tools that allow us to do this.</p>

            <p class="lead">We can use the <code>a2ensite</code> tool to enable each of our sites like this:</p>

            <p class="lead"><code>sudo a2ensite example.com.conf sudo a2ensite test.com.conf</code></p>

            <p class="lead">When you are finished, you need to restart Apache to make these changes take effect:</p>

            <p class="lead"><code>sudo service apache2 restart</code></p>

            <p class="lead">You will most likely receive a message saying something similar to:</p>

            <ul>
              <li class="lead">Restarting web server apache2
                AH00558: apache2: Could not reliably determine the server’s fully qualified domain name, using 127.0.0.1. Set the <code class="highlighter-rouge">ServerName</code> directive globally to suppress this message
              </li>
            </ul>

            <p class="lead">This is a harmless message that does not affect our site.</p>

            <h3>Step Six — Set Up Local Hosts File (Optional)</h3>

            <p class="lead">If you haven’t been using actual domain names that you own to test this procedure and have been using some example domains instead, you can at least test the functionality of this process by temporarily modifying the <code>hosts</code> file on your local computer.</p>

            <p class="lead">This will intercept any requests for the domains that you configured and point them to your VPS server, just as the DNS system would do if you were using registered domains. This will only work from your computer though, and is simply useful for testing purposes.</p>

            <p class="lead">Make sure you are operating on your local computer for these steps and not your VPS server. You will need to know the computer’s administrative password or otherwise be a member of the administrative group.</p>

            <p class="lead">If you are on a Mac or Linux computer, edit your local file with administrative privileges by typing:</p>

            <p class="lead"><code>sudo nano /etc/hosts</code></p>

            <p class="lead">If you are on a Windows machine, you can <a href="https://support.microsoft.com/pt-pt/help/923947/you-cannot-modify-the-hosts-file-or-the-lmhosts-file-in-windows-vista" target="_blank">find instructions on altering your hosts file </a> here.</p>

            <p class="lead">The details that you need to add are the public IP address of your VPS server followed by the domain you want to use to reach that VPS.</p>

            <p class="lead">For the domains that I used in this guide, assuming that my VPS IP address is <code>111.111.111.111</code>, I could add the following lines to the bottom of my hosts file:</p>

            <p class="lead">127.0.0.1 localhost 127.0.1.1 guest-desktop 111.111.111.111 example.com 111.111.111.111 test.com</p>

            <p class="lead">This will direct any requests for <code>example.com</code> and <code>test.com</code> on our computer and send them to our server at <code>111.111.111.111</code>. This is what we want if we are not actually the owners of these domains in order to test our virtual hosts.</p>

            <p class="lead">Save and close the file.</p>

            <h3>Step Seven — Test your Results</h3>

            <p class="lead">Now that you have your virtual hosts configured, you can test your setup easily by going to the domains that you configured in your web browser:</p>

            <p class="lead"><code>http://example.com</code></p>

            <p class="lead">You should see a page that looks like this:</p>

            <p class="lead">Likewise, if you can visit your second page:</p>

            <p class="lead"><code>http://test.com</code></p>

            <p class="lead">You will see the file you created for your second site:</p>

            <p class="lead">If both of these sites work well, you’ve successfully configured two virtual hosts on the same server.</p>

            <p class="lead">If you adjusted your home computer’s hosts file, you may want to delete the lines you added now that you verified that your configuration works. This will prevent your hosts file from being filled with entries that are not actually necessary.</p>

            <p class="lead">If you need to access this long term, consider purchasing a domain name for each site you need and <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-host-name-with-digitalocean" target="_blank">setting it up to point to your VPS server</a></p>

            <h3>Conclusion</h3>

            <p class="lead">If you followed along, you should now have a single server handling two separate domain names. You can expand this process by following the steps we outlined above to make additional virtual hosts.</p>

            <p class="lead">There is no software limit on the number of domain names Apache can handle, so feel free to make as many as your server is capable of handling.</p>

            <p class="lead">New apache version has change in some way. If your apache version is 2.4 then you have to go to <code>/etc/apache2/</code>. There will be a file named <code>apache2.conf</code>. You have to edit that one(you should have root permission). Change directory text like this:</p>

            <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Directory /var/www/&gt;
              Options Indexes FollowSymLinks
              AllowOverride All
              Require all granted
              &lt;/Directory&gt;
            </code></pre></div></div>

            <p class="lead">Now restart apache.</p>

            <p class="lead"><code>service apache2 reload</code></p>

            <!--  -->

            <hr>

            <div class="text-center">
              <img src="/img/postfix.png" class="img-fluid"/>
              <h2 id="postfix16.04">How To Install and Configure Postfix on Ubuntu 16.04</h2>
            </div>
            <hr>
            <h3>Introduction</h3>
            <p class="lead">Postfix is a popular open-source Mail Transfer Agent (MTA) that can be used to route and deliver email on a Linux system.  It is estimated that around 25% of public mail servers on the internet run Postfix.</p>
            <p class="lead">In this guide, we'll teach you how to get up and running quickly with Postfix on an Ubuntu 16.04 server.</p>
            <hr>
            <h3>Prerequisites</h3>
            <p class="lead">In order to follow this guide, you should have access to a non-root user with <code>sudo</code> privileges.  You can follow our <a href="https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-16-04">Ubuntu 16.04 initial server setup guide</a> to create the necessary user.</p>
            <p class="lead">In order to properly configure Postfix, you will need a Fully Qualified Domain Name pointed at your Ubuntu 16.04 server.  You can find help on setting up your domain name with DigitalOcean by following <a href="https://www.digitalocean.com/community/articles/how-to-set-up-a-host-name-with-digitalocean">this guide</a>.  If you plan on accepting mail, you will need to make sure you have an MX record pointing to your mail server as well.</p>
            <p class="lead">For the purposes of this tutorial, we will assume that you are configuring a host that has the FQDN of <code>mail.example.com</code>.</p>
            <hr>
            <h3>Step 1: Install Postfix</h3>
            <p class="lead">Postfix is included in Ubuntu's default repositories, so installation is incredibly simple.</p>
            <p class="lead">To begin, update your local <code>apt</code> package cache and then install the software.  We will be passing in the <code>DEBIAN_PRIORITY=low</code> environmental variable into our installation command in order to answer some additional prompts:</p>
            <code>$ sudo apt-get update</code>
            <code>sudo DEBIAN_PRIORITY=low apt-get install postfix</code>
            <p class="lead">Use the following information to fill in your prompts correctly for your environment:</p>
            <ul>
              <li class="lead"><strong>General type of mail configuration?</strong>: For this, we will choose <strong>Internet Site</strong> since this matches our infrastructure needs.</li>
              <li class="lead"><strong>System mail name</strong>: This is the base domain used to construct a valid email address when only the account portion of the address is given.  For instance, the hostname of our server is <code>mail.example.com</code>, but we probably want to set the system mail name to <code>example.com</code> so that given the username <code>user1</code>, Postfix will use the address <code>user1@example.com</code>.</li>
              <li class="lead"><strong>Root and postmaster mail recipient</strong>: This is the Linux account that will be forwarded mail addressed to <code>root@</code> and <code>postmaster@</code>.  Use your primary account for this.  In our case, <strong>sammy</strong>.</li>
              <li class="lead"><strong>Other destinations to accept mail for</strong>: This defines the mail destinations that this Postfix instance will accept.  If you need to add any other domains that this server will be responsible for receiving, add those here, otherwise, the default should work fine.</li>
              <li class="lead"><strong>Force synchronous updates on mail queue?</strong>: Since you are likely using a journaled filesystem, accept <strong>No</strong> here.</li>
              <li class="lead"><strong>Local networks</strong>: This is a list of the networks that your mail server is configured to relay messages for.  The default should work for most scenarios.  If you choose to modify it, make sure to be very restrictive in regards to the network range.</li>
              <li class="lead"><strong>Mailbox size limit</strong>: This can be used to limit the size of messages.  Setting it to "0" disables any size restriction.</li>
              <li class="lead"><strong>Local address extension character</strong>: This is the character that can be used to separate the regular portion of the address from an extension (used to create dynamic aliases).</li>
              <li class="lead"><strong>Internet protocols to use</strong>: Choose whether to restrict the IP version that Postfix supports.  We'll pick "all" for our purposes.</li>
            </ul>
            <p class="lead">To be explicit, these are the settings we'll use for this guide:</p>
            <ul>
              <li class="lead"><strong>General type of mail configuration?</strong>: Internet Site</li>
              <li class="lead"><strong>System mail name</strong>: example.com (not mail.example.com)</li>
              <li class="lead"><strong>Root and postmaster mail recipient</strong>: sammy</li>
              <li class="lead"><strong>Other destinations to accept mail for</strong>: $myhostname, example.com, mail.example.com, localhost.example.com, localhost</li>
              <li class="lead"><strong>Force synchronous updates on mail queue?</strong>: No</li>
              <li class="lead"><strong>Local networks</strong>: 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128</li>
              <li class="lead"><strong>Mailbox size limit</strong>: 0</li>
              <li class="lead"><strong>Local address extension character</strong>: +</li>
              <li class="lead"><strong>Internet protocols to use</strong>: all</li>
            </ul>
            <p class="lead">If you need to ever return to re-adjust these settings, you can do so by typing:</p>
            <code>$ sudo dpkg-reconfigure postfix </code>
            <p class="lead">The prompts will be pre-populated with your previous responses.</p>
            <p class="lead">When you are finished, we can now do a bit more configuration to set up our system how we'd like it.</p>
            <hr>
            <h3>Step 2: Tweak the Postfix Configuration</h3>
            <p class="lead">Next, we can adjust some settings that the package did not prompt us for.</p>
            <p class="lead">To begin, we can set the mailbox.  We will use the <strong>Maildir</strong> format, which separates messages into individual files that are then moved between directories based on user action.  The other option is the <strong>mbox</strong> format (which we won't cover here) which stores all messages within a single file.</p>
            <p class="lead">We will set the <code>home_mailbox</code> variable to <code>Maildir/</code> which will create a directory structure under that name within the user's home directory.  The <code>postconf</code> command can be used to query or set configuration settings.  Configure <code>home_mailbox</code> by typing:</p>
            <code> $ sudo postconf -e 'home_mailbox= Maildir/'</code>
            <p></p>
            <p class="lead">Next, we can set the location of the <code>virtual_alias_maps</code> table.  This table maps arbitrary email accounts to Linux system accounts.  We will create this table at <code>/etc/postfix/virtual</code>.  Again, we can use the <code>postconf</code> command:</p>
            <code> $ sudo postconf -e 'virtual_alias_maps= hash:/etc/postfix/virtual'</code>
            <hr>
            <h3>Step 3: Map Mail Addresses to Linux Accounts</h3>
            <p class="lead">Next, we can set up the virtual maps file.  Open the file in your text editor:</p>
            <code> $ sudo nano /etc/postfix/virtual</code>
            <p class="lead">The virtual alias map table uses a very simple format.  On the left, you can list any addresses that you wish to accept email for.  Afterwards, separated by whitespace, enter the Linux user you'd like that mail delivered to.</p>
            <p class="lead">For example, if you would like to accept email at <code>contact@example.com</code> and <code>admin@example.com</code> and would like to have those emails delivered to the <code>sammy</code> Linux user, you could set up your file like this:</p>
            <div class="text-center">
              <code>/etc/postfix/virtual</code>
            </div>
            <code>contact@example.com sammy</br>
              admin@example.com sammy</code>
              <p></p>
              <p class="lead">After you've mapped all of the addresses to the appropriate server accounts, save and close the file.</p>
              <p class="lead">We can apply the mapping by typing:</p>
              <code> $ sudo postmap /etc/postfix/virtual</code>
              <p></p>
              <p class="lead">Restart the Postfix process to be sure that all of our changes have been applied:</p>
              <code>$ sudo systemctl restart postfix</code>
              <hr>
              <h3>Step 4: Adjust the Firewall</h3>
              <p class="lead">If you are running the UFW firewall, as configured in the initial server setup guide, we'll have to allow an exception for Postfix.</p>
              <p class="lead">You can allow connections to the service by typing:</p>
              <code>$ sudo ufw allow Postfix</code>
              <p></p>
              <p class="lead">The Postfix server component is installed and ready.  Next, we will set up a client that can handle the mail that Postfix will process.</p>
              <p class="lead">Before we install a client, we should make sure our <code>MAIL</code> environmental variable is set correctly.  The client will inspect this variable to figure out where to look for user's mail.</p>
              <p class="lead">In order for the variable to be set regardless of how you access your account (through <code>ssh</code>, <code>su</code>, <code>su -</code>, <code>sudo</code>, etc.) we need to set the variable in a few different locations.  We'll add it to <code>/etc/bash.bashrc</code> and a file within <code>/etc/profile.d</code> to make sure each user has this configured.</p>
              <p class="lead">To add the variable to these files, type:</p>
              <code>echo 'export MAIL=~/Maildir' | sudo tee -a /etc/bash.bashrc | sudo tee -a /etc/profile.d/mail.sh</code>
              <p></p>
              <p class="lead">To read the variable into your current session, you can source the <code>/etc/profile.d/mail.sh</code> file:</p>
              <code>source /etc/profile.d/mail.sh</code>
              <hr>
              <h3>Step 6: Install and Configure the Mail Client</h3>
              <p class="lead">In order to interact with the mail being delivered, we will install the <code>s-nail</code> package.  This is a variant of the BSD <code>xmail</code> client, which is feature-rich, can handle the Maildir format correctly, and is mostly backwards compatible.  The GNU version of <code>mail</code> has some frustrating limitations, such as always saving read mail to the mbox format regardless of the source format.</p>
              <p class="lead">To install the <code>s-nail</code> package, type:</p>
              <code>$ sudo apt-get install s-nail</code>
              <p></p>
              <p class="lead">We should adjust a few settings.  Open the <code>/etc/s-nail.rc</code> file in your editor:</p>
              <code>$ sudo nano /etc/s-nail.rc</code>
              <p></p>
              <p class="lead">Towards the bottom of the file, add the following options:</p>
              <div class="text-center">
                <code>/etc/s-nail.rc</code>
              </div>
              <code>. . .
              </br>set emptystart
            </br>set folder=Maildir
          </br>set record=+sent
        </code>
        <p></p>
        <p class="lead">This will allow the client to open even with an empty inbox.  It will also set the <code>Maildir</code> directory to the internal <code>folder</code> variable and then use this to create a <code>sent</code> mbox file within that, for storing sent mail.</p>
        <p class="lead">Now, we can test the client out.</p>
        <hr>
        <h4>Initializing the Directory Structure</h4>
        <p class="lead">The easiest way to create the Maildir structure within our home directory is to send ourselves an email.  We can do this with the <code>mail</code> command.  Because the <code>sent</code> file will only be available once the Maildir is created, we should disable writing to that for our initial email.  We can do this by passing the <code>-Snorecord</code> option.</p>
        <p class="lead">Send the email by piping a string to the <code>mail</code> command.  Adjust the command to mark your Linux user as the recipient:</p>
        <code>$ echo 'init' | mail -s 'init' -Snorecord sammy</code>
        <p></p>
        <p class="lead">You should get the following response:</p>
        <code>Output</code>
        <code>Can't canonicalize "/home/sammy/Maildir"</code>
        <p></p>
        <p class="lead">This is normal and will only show during this first message.  We can check to make sure the directory was created by looking for our <code>~/Maildir</code> directory:</p>
        <code>$ ls -R ~/Maildir</code>
        <p></p>
        <p class="lead">You should see the directory structure has been created and that a new message file is in the <code>~/Maildir/new</code> directory:</p>
        <code>Output</code></br>
        <code>/home/sammy/Maildir/:
        </br>cur  new  tmp

      </br>/home/sammy/Maildir/cur:

    </br>/home/sammy/Maildir/new:
  </br>1463177269.Vfd01I40e4dM691221.mail.example.com

</br>/home/sammy/Maildir/tmp:
</code>
<p></p>
<p class="lead">It looks like our mail has been delivered.</p>
<hr>
<h4>Managing Mail with the Client</h4>
<p class="lead">Use the client to check your mail:</p>
<code>$ mail</code>
<p></p>
<p class="lead">You should see your new message waiting:</p>
<code>Output</br>
  s-nail version v14.8.6.  Type ? for help.
</br>"/home/sammy/Maildir": 1 message 1 new
</br>&gt;N  1 sammy@example.com     Wed Dec 31 19:00   14/369   init
</code>
<p></p>
<p class="lead">Just hitting <strong>ENTER</strong> should display your message:</p>
<code>Output</br>[-- Message  1 -- 14 lines, 369 bytes --]:
</br>From sammy@example.com Wed Dec 31 19:00:00 1969
</br>Date: Fri, 13 May 2016 18:07:49 -0400
</br>To: sammy@example.com
</br>Subject: init
</br>Message-Id: &lt;20160513220749.A278F228D9@mail.example.com&gt;</br>
From: sammy@example.com
</br>init
</code>
<p></p>
<p class="lead">You can get back to your message list by typing <strong>h</strong>:</p>
<code>? d</code></br>
</br>
<p></p>
<code >output
</br>s-nail version v14.8.6.  Type ? for help.
</br>"/home/sammy/Maildir": 1 message 1 new
</br>&gt;R  1 sammy@example.com     Wed Dec 31 19:00   14/369   init
</code>
<p></p>
<p class="lead">You can get back to your message list by typing <strong>h</strong>:</p>
<code>? h</code></br>
</br>
<p></p>
<code>Output
</br>s-nail version v14.8.6.  Type ? for help.
</br>"/home/sammy/Maildir": 1 message 1 new
</br>&gt;R  1 sammy@example.com     Wed Dec 31 19:00   14/369   init
</code>
<p></p>
<p class="lead">Since this message isn't very useful, we can delete it with <strong>d</strong>:</p>
<code>? d</code></br>
<p></p>
<p class="lead">Quit to get back to the terminal by typing <strong>q</strong>:</p>
<code>? q</code></br>
<hr>
<h4>Sending Mail with the Client</h4>
<p class="lead">You can test sending mail by typing a message in a text editor:</p>
<code>$ nano ~/test_message</code>
<p></p>
<p class="lead">Inside, enter some text you'd like to email:</p>
<div class="text-center"><code>~/test_message</code></div>
<code>Hello,</br>
  This is a test.  Please confirm receipt!
</code></br>
<p></p>
<p class="lead">Using the <code>cat</code> command, we can pipe the message to the <code>mail</code> process.  This will send the message as your Linux user by default.  You can adjust the "From" field with the <code>-r</code> flag if you want to modify that value to something else:</p>
<code>$ cat ~/test_message | mail -s 'Test email subject line' -r from_field_account useremail.com</code>
<p></p>
<p class="lead">The options above are:</p>
<ul>
  <li class="lead"><code>-s</code>: The subject line of the email</li>
  <li class="lead"><code>-r</code>: An optional change to the "From:" field of the email.  By default, the Linux user you are logged in as will be used to populate this field.  The <code>-r</code> option allows you to override this.</li>
  <li class="lead"><code>user@email.com</code>: The account to send the email to.  Change this to be a valid account you have access to.</li>
</ul>
<p class="lead">You can view your sent messages within your <code>mail</code> client.  Start the interactive client again by typing:</p>
<code>$ mail</code>
<p></p>
<p class="lead">Afterwards, view your sent messages by typing:</p>
<code>? file +sent</code>
<p></p>
<p class="lead">You can manage sent mail using the same commands you use for incoming mail.</p>
<hr>
<h3>Conclusion</h3>
<p class="lead">You should now have Postfix configured on your Ubuntu 16.04 server.  Managing email servers can be a tough task for beginning administrators, but with this configuration, you should have basic MTA email functionality to get you started.</p>

<!--  -->





{% for entry in craft.entries.section('secscrpt') %}
{% for block in entry.matriz %}
<br>
{{ block.imagem }}
<h2 id="{{ block.dlink }}">{{ block.dlink }}</h2>
{{ block.body }}
<code>{{ block.codigo }}</code>
{% endfor %}
{% endfor %}


</div>
</main>
